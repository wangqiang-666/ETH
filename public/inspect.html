<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>数据与指标诊断面板</title>
  <link rel="icon" type="image/svg+xml" href="/eth-logo.svg" />
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; margin: 0; background: #f5f7fb; color: #2c3e50; }
    .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
    .header { background: #fff; border-radius: 14px; padding: 20px; box-shadow: 0 8px 24px rgba(0,0,0,0.06); margin-bottom: 16px; }
    .row { display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap: 16px; }
    .card { background: #fff; border-radius: 14px; padding: 16px; box-shadow: 0 8px 24px rgba(0,0,0,0.06); }
    .card h3 { margin: 0 0 10px; font-size: 16px; color: #1f2d3d; }
    .toolbar { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
    .toolbar input, .toolbar select { padding: 8px 10px; border: 1px solid #e1e4ea; border-radius: 8px; }
    .btn { background: #2f80ed; color: #fff; border: none; padding: 8px 14px; border-radius: 8px; cursor: pointer; }
    .btn:disabled { opacity: 0.6; cursor: not-allowed; }
    .kv { display: grid; grid-template-columns: 140px 1fr; gap: 6px 10px; font-size: 13px; }
    .kv div { padding: 4px 0; border-bottom: 1px dashed #eef2f7; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; background: #0b1020; color: #e2e8f0; padding: 10px; border-radius: 10px; overflow: auto; max-height: 300px; }
    .ok { color: #10b981; font-weight: 600; }
    .warn { color: #f59e0b; font-weight: 600; }
    .err { color: #ef4444; font-weight: 600; }
    details summary { cursor: pointer; user-select: none; }
    /* 新增：状态样式与微型进度提示 */
    .status { color: #6b7280; font-size: 12px; margin-left: 8px; }
    .badge { display: inline-block; padding: 2px 6px; border-radius: 6px; font-size: 12px; }
    .badge.ok { background: #ecfdf5; color: #065f46; }
    .badge.warn { background: #fffbeb; color: #92400e; }
    .badge.err { background: #fef2f2; color: #991b1b; }
    @keyframes spin { to { transform: rotate(360deg); } }
    .spinner { width: 12px; height: 12px; border: 2px solid #c7d2fe; border-top-color: #4f46e5; border-radius: 50%; display: inline-block; animation: spin 0.8s linear infinite; margin-right: 6px; }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h2>数据与指标诊断面板</h2>
      <p style="color:#6b7280; margin:6px 0 12px;">展示分析所用的所有关键数据、指标与参数，帮助定位数据异常（如 24h 涨跌幅）。</p>
      <div class="toolbar">
        <label>交易对</label>
        <input id="symbol" value="ETH-USDT-SWAP" />
        <label>周期</label>
        <select id="interval">
          <option value="1m">1m</option>
          <option value="3m">3m</option>
          <option value="5m">5m</option>
          <option value="15m">15m</option>
          <option value="1H">1H</option>
        </select>
        <label>根数</label>
        <input id="limit" type="number" value="120" min="50" max="1000" />
        <button id="refresh" class="btn">刷新</button>
        <label><input id="auto" type="checkbox" checked /> 自动每30秒刷新</label>
        <!-- 新增：刷新状态与倒计时提示 -->
        <span id="loadingTip" class="status" style="display:none"><span class="spinner"></span>刷新中...</span>
        <span id="lastUpdated" class="status"></span>
        <span id="countdown" class="status"></span>
      </div>
    </div>

    <div class="row">
      <div class="card">
        <h3>市场 Ticker <span id="tickerStatus" class="badge warn" style="display:none"></span></h3>
        <div id="tickerKv" class="kv"></div>
        <details style="margin-top:8px">
          <summary>市场Ticker原始JSON</summary>
          <pre id="tickerRaw" class="mono"></pre>
        </details>
      </div>

      <div class="card">
        <h3>K线与校验 <span id="klineStatus" class="badge warn" style="display:none"></span></h3>
        <div id="klineKv" class="kv"></div>
        <details style="margin-top:8px">
          <summary>K线/校验原始JSON</summary>
          <pre id="klineRaw" class="mono"></pre>
        </details>
      </div>

      <div class="card">
        <h3>交叉核验与关键指标 <span id="indStatus" class="badge warn" style="display:none"></span></h3>
        <div id="indKv" class="kv"></div>
        <details style="margin-top:8px">
          <summary>指标原始 JSON</summary>
          <pre id="indRaw" class="mono"></pre>
        </details>
      </div>
    </div>

    <div class="row" style="margin-top:16px;">
      <div class="card">
        <h3>策略分析参数 <span id="analysisStatus" class="badge warn" style="display:none"></span></h3>
        <div id="analysisKv" class="kv"></div>
        <details style="margin-top:8px">
          <summary>Analysis 原始 JSON</summary>
          <pre id="analysisRaw" class="mono"></pre>
        </details>
      </div>

      <div class="card">
        <h3>实时绩效 <span id="perfStatus" class="badge warn" style="display:none"></span></h3>
        <div id="perfKv" class="kv"></div>
        <details style="margin-top:8px">
          <summary>Performance 原始 JSON</summary>
          <pre id="perfRaw" class="mono"></pre>
        </details>
      </div>

      <div class="card">
        <h3>系统配置 <span id="configStatus" class="badge warn" style="display:none"></span></h3>
        <div id="configKv" class="kv"></div>
        <details style="margin-top:8px">
          <summary>Config 原始 JSON</summary>
          <pre id="configRaw" class="mono"></pre>
        </details>
        <!-- 新增：策略冷却与反向置信度配置编辑区 -->
        <details style="margin-top:10px">
          <summary>策略冷却/置信度 配置编辑</summary>
          <p class="status">说明：冷却时间为非负整数（毫秒）；置信度为 0~1 之间的小数。留空表示不修改。若同时设置全局和分方向置信度，分方向将覆盖对应方向。</p>
          <div class="kv" style="margin-top:8px">
            <div>全局最小间隔 globalMinIntervalMs</div>
            <div><input id="globalMinIntervalMs" type="number" min="0" step="1" placeholder="ms" style="width:160px" /></div>

            <div>同向冷却 sameDir.LONG</div>
            <div><input id="cdSameLong" type="number" min="0" step="1" placeholder="ms" style="width:160px" /></div>
            <div>同向冷却 sameDir.SHORT</div>
            <div><input id="cdSameShort" type="number" min="0" step="1" placeholder="ms" style="width:160px" /></div>
            
            <div>反向冷却 opposite.LONG</div>
            <div><input id="cdOppLong" type="number" min="0" step="1" placeholder="ms" style="width:160px" /></div>
            <div>反向冷却 opposite.SHORT</div>
            <div><input id="cdOppShort" type="number" min="0" step="1" placeholder="ms" style="width:160px" /></div>
            
            <div>反向最小置信度 oppositeMinConfidence</div>
            <div><input id="oppMinConf" type="number" min="0" max="1" step="0.01" placeholder="0~1" style="width:160px" /></div>

            <div>反向最小置信度(LONG) byDirection.LONG</div>
            <div><input id="oppMinConfLong" type="number" min="0" max="1" step="0.01" placeholder="0~1 (可选)" style="width:160px" /></div>
            <div>反向最小置信度(SHORT) byDirection.SHORT</div>
            <div><input id="oppMinConfShort" type="number" min="0" max="1" step="0.01" placeholder="0~1 (可选)" style="width:160px" /></div>

            <div>反向并存开关 allowOppositeWhileOpen</div>
            <div>
              <input id="allowOppositeWhileOpen" type="checkbox" />
              <span class="hint">允许在有仓位时开反向</span>
            </div>

            <div style="margin-top:12px; border-top:1px solid #ddd; padding-top:12px;">
              <strong>EV阈值配置 evThreshold</strong>
            </div>
            <div>默认阈值 default</div>
            <div><input id="evDef" type="number" step="0.01" placeholder="数值" style="width:160px" /></div>
            <div style="margin-top:8px;"><em>按波动分类 byVolatility</em></div>
            <div>高波动 HIGH</div>
            <div><input id="evVolH" type="number" step="0.01" placeholder="数值" style="width:160px" /></div>
            <div>中波动 MEDIUM</div>
            <div><input id="evVolM" type="number" step="0.01" placeholder="数值" style="width:160px" /></div>
            <div>低波动 LOW</div>
            <div><input id="evVolL" type="number" step="0.01" placeholder="数值" style="width:160px" /></div>
            <div style="margin-top:8px;"><em>按市场状态 byRegime</em></div>
            <div>趋势市场 TREND</div>
            <div><input id="evRegT" type="number" step="0.01" placeholder="数值" style="width:160px" /></div>
            <div>震荡市场 RANGE</div>
            <div><input id="evRegR" type="number" step="0.01" placeholder="数值" style="width:160px" /></div>

            <div></div>
            <div>
              <button id="saveStrategyCfg" class="btn">保存</button>
              <span id="saveCfgStatus" class="status" style="margin-left:8px"></span>
            </div>
          </div>
        </details>
      </div>
    </div>

    <div class="row" style="margin-top:16px;">
      <div class="card">
        <h3>数据服务健康与性能 <span id="svcStatus" class="badge warn" style="display:none"></span></h3>
        <div id="svcKv" class="kv"></div>
        <details style="margin-top:8px">
          <summary>健康/性能/缓存原始 JSON</summary>
          <pre id="svcRaw" class="mono"></pre>
        </details>
      </div>

      <div class="card">
        <h3>聚合原始数据</h3>
        <pre id="allRaw" class="mono" style="max-height:600px"></pre>
      </div>
    </div>
  </div>

  <script>
    const $ = (id) => document.getElementById(id);
    let timer = null;
    let countdownTimer = null;
    const autoIntervalMs = 30000;
    let loading = false; // 并发保护
    const rawPayloads = {}; // 存放各面板原始数据，供 details 展开时序列化
    let currentLoadCtrl = null; // 新增：每次刷新使用的全局 AbortController

    // ===== 通用工具函数（全局可用）=====
    function resolveApiUrl(u) {
      try {
        if (typeof u === 'string' && u.startsWith('/api')) {
          // 始终同源访问，避免错误地重写到其他端口（如 3002）导致加载失败
          return u; // same-origin
        }
      } catch (_) {}
      return u;
    }
     async function getJson(url, timeoutMs = 5000, retries = 1, opts = {}) {
       const extSignal = opts && opts.signal; // 外部取消信号（用于刷新时中断上一轮）
       const maxTimeout = 30000;
       const doFetch = async (toMs) => {
         const ctrl = new AbortController();
         const id = setTimeout(() => ctrl.abort(), Math.min(Math.max(toMs, 3000), maxTimeout));
         const combined = extSignal ? anySignal(ctrl.signal, extSignal) : ctrl.signal; // 合并信号
         try {

          const res = await fetch(resolveApiUrl(url), { signal: combined });
           if (!res.ok) throw new Error(`HTTP ${res.status}`);
           const ct = res.headers.get('content-type') || '';
           if (ct.includes('application/json')) return await res.json();
           const text = await res.text();
           try { return JSON.parse(text); } catch { return { raw: text }; }
         } finally {
           clearTimeout(id);
         }
       };
       let attempt = 0;
       let curTimeout = timeoutMs;
       while (true) {
        try {
          return await doFetch(curTimeout);
        } catch (e) {
          // 若是因为“新一轮刷新”触发的外部取消，静默抛出专用错误，供上层识别
          if (extSignal && extSignal.aborted) {
            const cancelErr = new Error('CanceledByNewLoad');
            cancelErr.name = 'CanceledByNewLoad';
            throw cancelErr;
          }
          const isAbort = (e && (e.name === 'AbortError' || /aborted/i.test(String(e.message))));
          if (attempt < retries && isAbort) {
            attempt += 1;
            curTimeout = Math.min(Math.floor(curTimeout * 2), 30000);
            continue;
          }
          if (isAbort) {
            const err = new Error(`Timeout after ${curTimeout}ms: ${url}`);
            err.name = 'TimeoutError';
            throw err;
          }
          throw e;
        }
      }
    }
    
    // 新增：将两个 AbortSignal 合并为一个（任一取消都会传播）
    function anySignal(a, b) {
      if (a && !b) return a;
      if (b && !a) return b;
      if (!a && !b) return undefined;
      const ctrl = new AbortController();
      const onAbortA = () => { if (!ctrl.signal.aborted) ctrl.abort(a.reason || new Error('aborted')); };
      const onAbortB = () => { if (!ctrl.signal.aborted) ctrl.abort(b.reason || new Error('aborted')); };
      a.addEventListener('abort', onAbortA);
      b.addEventListener('abort', onAbortB);
      if (a.aborted) onAbortA();
      if (b.aborted) onAbortB();
      return ctrl.signal;
    }
    
    // 新增：sleep 工具（用于退避等场景的节流）
    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
    function pct(x) {
      if (typeof x !== 'number' || !isFinite(x)) return '—';
      return (x * 100).toFixed(2) + '%';
    }
    function pctp(x) {
      if (typeof x !== 'number' || !isFinite(x)) return '—';
      return x.toFixed(2) + '%';
    }
    function money(x) {
      if (typeof x !== 'number' || !isFinite(x)) return '—';
      return '$' + x.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    }
    function formatUSDT(x) {
      if (typeof x !== 'number' || !isFinite(x)) return '—';
      const abs = Math.abs(x);
      if (abs >= 1e9) return '$' + (x / 1e9).toFixed(2) + 'B';
      if (abs >= 1e6) return '$' + (x / 1e6).toFixed(2) + 'M';
      if (abs >= 1e3) return '$' + (x / 1e3).toFixed(2) + 'K';
      return '$' + x.toFixed(2);
    }
    function kv(el, obj) {
      if (!el || !obj || typeof obj !== 'object') return;
      const html = Object.entries(obj).map(([k, v]) => `
        <div>${k}</div>
        <div>${v}</div>
      `).join('');
      el.innerHTML = html;
    }
    function safeStringify(obj, space = 2) {
      const seen = new WeakSet();
      return JSON.stringify(obj, (k, v) => {
        if (typeof v === 'bigint') return v.toString();
        if (typeof v === 'object' && v !== null) {
          if (seen.has(v)) return '[Circular]';
          seen.add(v);
        }
        return v;
      }, space);
    }
    function bindLazyForPre(preId, payloadKey) {
      const pre = $(preId);
      if (!pre) return;
      const det = pre.closest('details');
      if (!det) return;
      const fill = () => {
        const data = rawPayloads[payloadKey];
        pre.textContent = safeStringify(data, 2);
      };
      det.addEventListener('toggle', () => {
        if (det.open) fill();
      });
    }
    function fmtTs(ts) {
      if (ts == null) return '—';
      let ms = Number(ts);
      if (!isFinite(ms)) {
        const parsed = Date.parse(ts);
        if (!isFinite(parsed)) return String(ts);
        ms = parsed;
      }
      const d = new Date(ms);
      if (!isFinite(d.getTime())) return String(ts);
      try {
        return d.toLocaleString('zh-CN', { hour12: false, timeZone: 'Asia/Shanghai' });
      } catch (_) {
        return d.toISOString().replace('T', ' ').replace('Z', ' UTC');
      }
    }

    // 新增：卡片状态与全局状态工具
    function setBadge(id, type, text) {
      const el = $(id);
      if (!el) return;
      el.style.display = text ? 'inline-block' : 'none';
      el.className = `badge ${type || ''}`.trim();
      el.textContent = text || '';
    }
    function setLoadingUI(isLoading) {
      $('loadingTip').style.display = isLoading ? 'inline' : 'none';
      $('refresh').disabled = isLoading;
      $('refresh').textContent = isLoading ? '刷新中…' : '刷新';
      if (isLoading) {
        // 清除倒计时显示
        $('countdown').textContent = '';
      }
    }
    function setLastUpdated(ts) {
      $('lastUpdated').textContent = ts ? `上次更新：${fmtTs(ts)}` : '';
    }
    function startCountdown(ms) {
      clearInterval(countdownTimer);
      let remain = Math.floor(ms / 1000);
      $('countdown').textContent = `将于 ${remain}s 后自动刷新`;
      countdownTimer = setInterval(() => {
        remain -= 1;
        if (remain <= 0) {
          $('countdown').textContent = '正在自动刷新…';
          clearInterval(countdownTimer);
        } else {
          $('countdown').textContent = `将于 ${remain}s 后自动刷新`;
        }
      }, 1000);
    }

    // 渲染函数（占位实现，确保页面可运行）
    function renderTickerCard(data, type = 'ok', text = '') {
      try {
        const d = data || {};
        // 新增：按张折算的 USDT 成交额计算（兼容数值/字符串）
        const priceNum = Number(typeof d.price === 'number' ? d.price : (d.price ?? d.last ?? (d.data && d.data.price)));
        const volLots = Number(d.volume);
        const turnoverUSDT = (Number.isFinite(volLots) && Number.isFinite(priceNum)) ? volLots * priceNum * 0.1 : NaN;
    
        setBadge('tickerStatus', type || (d && d.price != null ? 'ok' : 'warn'), text || (d && d.price != null ? '已更新' : '暂无数据'));
        kv($('tickerKv'), {
          '最新价 Last Price': (typeof d.price === 'number') ? d.price.toFixed(2) : (d.price ?? '—'),
          '24h 变动 24h Change': (typeof d.change24h === 'number') ? pctp(d.change24h) : '—',
          '24h 最高 High 24h': (typeof d.high24h === 'number') ? d.high24h.toFixed(2) : '—',
          '24h 最低 Low 24h': (typeof d.low24h === 'number') ? d.low24h.toFixed(2) : '—',
          // 修改：成交量单位标注为“张”
          '24h 成交量 Volume 24h': (Number.isFinite(volLots)) ? (volLots.toLocaleString() + ' 张') : '—',
          // 新增：按张折算的 USDT 成交额
          '24h 成交额(按张折算, USDT) Turnover 24h (Lots)': Number.isFinite(turnoverUSDT) ? formatUSDT(turnoverUSDT) : '—',
          '开盘价(滚动24h) Open24h Price': (typeof d.open24hPrice === 'number') ? d.open24hPrice.toFixed(2) : '—',
          '当日开盘价(UTC+8) SodUtc8 Price': (typeof d.sodUtc8Price === 'number') ? d.sodUtc8Price.toFixed(2) : '—',
          '相对当日开盘变动 Change From SOD(UTC+8)': (typeof d.changeFromSodUtc8 === 'number') ? pctp(d.changeFromSodUtc8) : '—',
          '时间 Timestamp': (d.timestamp != null) ? `${fmtTs(d.timestamp)} (${d.timestamp})` : '—'
        });
        if ($('tickerRaw')) $('tickerRaw').textContent = safeStringify(d, 2);
      } catch (_) {}
    }

    function renderKlineCard(diag, ticker, k24) {
      try {
        const cc = diag?.crossChecks || {};
        const v = diag?.validation || {};
    
        // 解析24h K线窗口（limit=25，取最近24根已收盘K线进行统计）
        let k24High = null, k24Low = null, k24Vol = null, k24Open = null, k24Change = null;
        try {
          const kd = Array.isArray(k24) ? k24 : (k24 && Array.isArray(k24.data) ? k24.data : null);
          if (Array.isArray(kd) && kd.length >= 2) {
            const arr = kd.slice(-24);
            const highs = arr.map(k => Number(k.high)).filter(n => Number.isFinite(n));
            const lows = arr.map(k => Number(k.low)).filter(n => Number.isFinite(n));
            const vols = arr.map(k => Number(k.volume)).filter(n => Number.isFinite(n));
            const opens = arr.map(k => Number(k.open)).filter(n => Number.isFinite(n));
            const closes = arr.map(k => Number(k.close)).filter(n => Number.isFinite(n));
            if (highs.length > 0 && lows.length > 0 && closes.length > 0) {
              k24High = Math.max(...highs);
              k24Low = Math.min(...lows);
              k24Vol = vols.reduce((a, b) => a + b, 0);
              const turnover = arr.reduce((acc, k) => {
                const v = Number(k.volume); const c = Number(k.close);
                return (Number.isFinite(v) && Number.isFinite(c)) ? acc + v * c * 0.1 : acc;
              }, 0);
              k24TurnoverUSDT = Number.isFinite(turnover) ? turnover : null;
              k24Open = opens[0];
              const lastClose = closes[closes.length - 1];
              if (Number.isFinite(k24Open) && Number.isFinite(lastClose) && k24Open > 0) {
                k24Change = ((lastClose - k24Open) / k24Open) * 100; // 百分比
              }
            }
          }
        } catch (_) {}

        // 新增：兼容后端字段名差异的回退逻辑
        const vAlt = diag?.klineValidation || {};
        const vOk = (typeof v?.ok === 'boolean') ? v.ok : (typeof vAlt?.valid === 'boolean' ? vAlt.valid : undefined);
        const meanVolVal = (typeof cc.meanVolume === 'number') ? cc.meanVolume : (typeof vAlt?.metrics?.avgVol === 'number' ? vAlt.metrics.avgVol : undefined);
        const dataTs = (diag?.dataTs != null) ? diag.dataTs : (typeof vAlt?.metrics?.endTs === 'number' ? vAlt.metrics.endTs : undefined);
    
        kv($('klineKv'), {
          '最后收盘 Last Close': (typeof cc.lastClose === 'number') ? cc.lastClose.toFixed(2) : '—',
          '均量 Mean Volume(张)': (typeof meanVolVal === 'number') ? meanVolVal.toLocaleString() : '—',
          'K线可用 Kline OK': (vOk === true ? 'true' : vOk === false ? 'false' : '—'),
          '数据时间 Data Time': (dataTs != null) ? `${fmtTs(dataTs)} (${dataTs})` : '—',
          '24h 高(按K线) High 24h (K)': (typeof k24High === 'number') ? k24High.toFixed(2) : '—',
          '24h 低(按K线) Low 24h (K)': (typeof k24Low === 'number') ? k24Low.toFixed(2) : '—',
          '24h 成交量(按K线, 张) Volume 24h (K, Lots)': (k24Vol != null && Number.isFinite(k24Vol)) ? k24Vol.toLocaleString() : '—',
          '24h 成交额(按K线, USDT) Turnover 24h (K)': (typeof k24TurnoverUSDT === 'number') ? formatUSDT(k24TurnoverUSDT) : '—',
          '24h 变动(按K线) Change 24h (K)': (typeof k24Change === 'number') ? pctp(k24Change) : '—'
        });
        if ($('klineRaw')) $('klineRaw').textContent = safeStringify(diag, 2);
        setBadge('klineStatus', vOk === false ? 'warn' : 'ok', vOk === false ? '校验警告' : '已更新');
      } catch (_) {}
    }

    function renderIndCard(diag, ticker, k24) {
      try {
        const src = (diag && diag.indicators) || {};
        const ind = (src && typeof src === 'object' && (('current' in src) || ('issues' in src))) ? (src.current || {}) : src;
        const macd = ind.macd || {};
        const bb = ind.bollinger || {};
        const kdj = ind.kdj || {};
        const obv = ind.obv || {};
        const vwap = ind.vwap || {};
        const kelt = ind.keltner || {};
        const vol = ind.volume || {};

        // 24h 对比：基于 k24 与 ticker
        let k24High = null, k24Low = null, distHigh = null, distLow = null, amp = null;
        try {
          const kd = Array.isArray(k24) ? k24 : (k24 && Array.isArray(k24.data) ? k24.data : null);
          if (Array.isArray(kd) && kd.length >= 2) {
            const arr = kd.slice(-24);
            const highs = arr.map(k => Number(k.high)).filter(n => Number.isFinite(n));
            const lows = arr.map(k => Number(k.low)).filter(n => Number.isFinite(n));
            if (highs.length > 0 && lows.length > 0) {
              k24High = Math.max(...highs);
              k24Low = Math.min(...lows);
            }
          }
        } catch (_) {}
        const price = (ticker && typeof ticker === 'object')
          ? (typeof ticker.price === 'number' ? ticker.price
            : (ticker.data && typeof ticker.data.price === 'number' ? ticker.data.price : null))
          : null;
        if (price != null) {
          if (typeof k24High === 'number' && k24High > 0) distHigh = (price - k24High) / k24High;
          if (typeof k24Low === 'number' && k24Low > 0) distLow = (price - k24Low) / k24Low;
          if (typeof k24High === 'number' && typeof k24Low === 'number' && (price > 0 || (k24High + k24Low) > 0)) {
            const base = price > 0 ? price : ((k24High + k24Low) / 2);
            amp = (k24High - k24Low) / base;
          }
        }
        const volUSDTCurrent = (typeof vol.current === 'number' && typeof price === 'number') ? vol.current * price * 0.1 : NaN;
        const volUSDTAvg = (typeof vol.average === 'number' && typeof price === 'number') ? vol.average * price * 0.1 : NaN;

        kv($('indKv'), {
          'RSI': (typeof ind.rsi === 'number') ? ind.rsi.toFixed(2) : '—',
          'MACD': (typeof macd.macd === 'number') ? macd.macd.toFixed(4) : '—',
          'Signal': (typeof macd.signal === 'number') ? macd.signal.toFixed(4) : '—',
          'Hist': (typeof macd.histogram === 'number') ? macd.histogram.toFixed(4) : '—',
          '布林上轨 BB Upper': (typeof bb.upper === 'number') ? bb.upper.toFixed(2) : '—',
          '布林中轨 BB Middle': (typeof bb.middle === 'number') ? bb.middle.toFixed(2) : '—',
          '布林下轨 BB Lower': (typeof bb.lower === 'number') ? bb.lower.toFixed(2) : '—',
          'KDJ-K': (typeof kdj.k === 'number') ? kdj.k.toFixed(2) : '—',
          'KDJ-D': (typeof kdj.d === 'number') ? kdj.d.toFixed(2) : '—',
          'KDJ-J': (typeof kdj.j === 'number') ? kdj.j.toFixed(2) : '—',
          'OBV': (typeof obv.current === 'number') ? obv.current.toLocaleString() : '—',
          '成交量(张) Volume': (typeof vol.current === 'number') ? (vol.current.toLocaleString() + ' 张') : '—',
          '均量(张) Avg Volume': (typeof vol.average === 'number') ? (vol.average.toLocaleString() + ' 张') : '—',
          '量比 Volume Ratio': (typeof vol.ratio === 'number') ? vol.ratio.toFixed(2) : '—',
          '成交额(当前, USDT估算)': Number.isFinite(volUSDTCurrent) ? formatUSDT(volUSDTCurrent) : '—',
          '成交额(均值, USDT估算)': Number.isFinite(volUSDTAvg) ? formatUSDT(volUSDTAvg) : '—',
          '距离24h高 Dist to 24h High': (typeof distHigh === 'number') ? pct(distHigh) : '—',
          '距离24h低 Dist to 24h Low': (typeof distLow === 'number') ? pct(distLow) : '—',
          '24h 振幅(相对价) 24h Amplitude(Rel)': (typeof amp === 'number') ? pct(amp) : '—'
        });
        if ($('indRaw')) $('indRaw').textContent = safeStringify(diag, 2);
        setBadge('indStatus', 'ok', '已更新');
      } catch (_) {}
    }

    function renderSvcCard(diag) {
      try {
        const health = diag?.health || {};
        const perf = diag?.performance || {};
        const cache = diag?.cache || {};
        // 新增：兼容后端字段名差异
        const healthOK = (typeof health.ok === 'boolean')
          ? health.ok
          : (typeof health.status === 'string' ? (String(health.status).toLowerCase() === 'connected') : undefined);
        const latencyMs = (typeof perf.latencyMs === 'number') ? perf.latencyMs
          : (typeof perf.latency === 'number') ? perf.latency
          : (typeof perf?.current?.networkLatency === 'number') ? perf.current.networkLatency
          : (typeof perf?.current?.responseTime === 'number') ? perf.current.responseTime
          : undefined;
        // 新增：提取更多性能指标（带兜底）
        const cur = perf && typeof perf === 'object' ? (perf.current || {}) : {};
        const avg = perf && typeof perf === 'object' ? (perf.average || {}) : {};
        const peak = perf && typeof perf === 'object' ? (perf.peak || {}) : {};
        const throughput = (typeof cur.throughput === 'number') ? cur.throughput : undefined;
        const errorRate = (typeof cur.errorRate === 'number') ? cur.errorRate : undefined;
        const cpuUsage = (typeof cur.cpuUsage === 'number') ? cur.cpuUsage : undefined;
        const memoryUsage = (typeof cur.memoryUsage === 'number') ? cur.memoryUsage : undefined;
        const activeConnections = (typeof cur.activeConnections === 'number') ? cur.activeConnections : undefined;
        const queueLength = (typeof cur.queueLength === 'number') ? cur.queueLength : undefined;
        const avgLatency = (typeof avg.networkLatency === 'number') ? avg.networkLatency : (typeof avg.responseTime === 'number' ? avg.responseTime : undefined);
        const peakLatency = (typeof peak.networkLatency === 'number') ? peak.networkLatency : (typeof peak.responseTime === 'number' ? peak.responseTime : undefined);
        function fmtPctAuto(x){ if(typeof x!== 'number' || !isFinite(x)) return undefined; return x>1? `${x.toFixed(2)}%` : `${(x*100).toFixed(2)}%`; }
        function fmtCacheHitAuto(x){ if(typeof x!== 'number' || !isFinite(x)) return undefined; return x>1? pct(x/100) : pct(x); }
        const curCacheHit = (typeof cur.cacheHitRate === 'number') ? fmtCacheHitAuto(cur.cacheHitRate) : undefined;
        const avgErrorRate = (typeof avg.errorRate === 'number') ? fmtPctAuto(avg.errorRate) : undefined;
        const peakErrorRate = (typeof peak.errorRate === 'number') ? fmtPctAuto(peak.errorRate) : undefined;
        const avgCacheHit = (typeof avg.cacheHitRate === 'number') ? fmtCacheHitAuto(avg.cacheHitRate) : undefined;
        const peakCacheHit = (typeof peak.cacheHitRate === 'number') ? fmtCacheHitAuto(peak.cacheHitRate) : undefined;

        kv($('svcKv'), {
          '服务健康 Service OK': (healthOK === true ? 'true' : healthOK === false ? 'false' : '—'),
          '最近延迟 Latency(ms)': (typeof latencyMs === 'number') ? latencyMs.toFixed(0) : '—',
          '吞吐量 Throughput/s': (typeof throughput === 'number') ? throughput.toFixed(2) : '—',
          '错误率 Error Rate': (typeof errorRate === 'number') ? fmtPctAuto(errorRate) : '—',
          'CPU 使用 CPU%': (typeof cpuUsage === 'number') ? `${cpuUsage.toFixed(1)}%` : '—',
          '内存 Memory(MB)': (typeof memoryUsage === 'number') ? `${memoryUsage.toFixed(1)}MB` : '—',
          '活动连接 Active Conns': (typeof activeConnections === 'number') ? String(activeConnections) : '—',
          '队列长度 Queue Len': (typeof queueLength === 'number') ? String(queueLength) : '—',
          '平均延迟 Avg Latency(ms)': (typeof avgLatency === 'number') ? avgLatency.toFixed(0) : '—',
          '峰值延迟 Peak Latency(ms)': (typeof peakLatency === 'number') ? peakLatency.toFixed(0) : '—',
          '平均错误率 Avg Error Rate': (avgErrorRate ?? '—'),
          '峰值错误率 Peak Error Rate': (peakErrorRate ?? '—'),
          '缓存命中 Cache Hit': (curCacheHit ?? (typeof cache.hitRate === 'number' ? pct(cache.hitRate) : (cache.hits != null && cache.total != null ? `${cache.hits}/${cache.total}` : '—'))),
          '平均缓存命中 Avg Cache Hit': (avgCacheHit ?? '—'),
          '峰值缓存命中 Peak Cache Hit': (peakCacheHit ?? '—')
        });
        rawPayloads.svc = { health, performance: perf, cache };
        if ($('svcRaw')) $('svcRaw').textContent = safeStringify(rawPayloads.svc, 2);
        setBadge('svcStatus', 'ok', '已更新');
      } catch (_) {}
    }

    // 新增：字段校验辅助与样式注入
    function ensureValidationStyle() {
      if (document.getElementById('validation-style')) return;
      const style = document.createElement('style');
      style.id = 'validation-style';
      style.textContent = `
        .invalid { border-color: #e00 !important; box-shadow: inset 0 0 0 2px rgba(255,0,0,0.12); }
        .hint { color:#666; font-size:12px; }
      `;
      document.head.appendChild(style);
    }
    function markInvalid(el, msg) {
      if (!el) return;
      el.classList.add('invalid');
      if (msg) el.title = msg; else el.removeAttribute('title');
    }
    function clearInvalid(el) {
      if (!el) return;
      el.classList.remove('invalid');
      el.removeAttribute('title');
    }
    function isNonNegInt(n) { return Number.isInteger(n) && n >= 0; }
    function isProb(n) { return typeof n === 'number' && isFinite(n) && n >= 0 && n <= 1; }
    function isFiniteNum(n) { return typeof n === 'number' && Number.isFinite(n); }

    function numOrEmpty(v) {
      if (v === null || v === undefined) return undefined;
      const s = String(v).trim();
      if (s === '') return undefined;
      const n = Number(s);
      return Number.isFinite(n) ? n : undefined;
    }

    // 新增：输入实时校验（整数/概率）
    function attachStrategyInputValidation() {
      const intIds = ['globalMinIntervalMs','cdSameLong','cdSameShort','cdOppLong','cdOppShort'];
      const probIds = ['oppMinConf','oppMinConfLong','oppMinConfShort'];
      intIds.forEach(id => {
        const el = $(id);
        if (!el) return;
        el.addEventListener('input', () => {
          const v = numOrEmpty(el.value);
          if (v === undefined || isNonNegInt(v)) clearInvalid(el); else markInvalid(el, '必须为非负整数');
        });
      });
      probIds.forEach(id => {
        const el = $(id);
        if (!el) return;
        el.addEventListener('input', () => {
          const v = numOrEmpty(el.value);
          if (v === undefined || isProb(v)) clearInvalid(el); else markInvalid(el, '必须在 [0,1]');
        });
      });
      // 数值类型（EV 阈值）
      const numIds = ['evDef','evVolH','evVolM','evVolL','evRegT','evRegR'];
      numIds.forEach(id => {
        const el = $(id);
        if (!el) return;
        el.addEventListener('input', () => {
          const v = numOrEmpty(el.value);
          if (v === undefined || isFiniteNum(v)) clearInvalid(el); else markInvalid(el, '必须为数值');
        });
      });
    }

    function fillStrategyEdit(strategy) {
      try {
        const s = strategy || {};
        const cd = (s.cooldown) || {};
        const same = cd.sameDir || {};
        const opp = cd.opposite || {};
        const gms = (typeof s.globalMinIntervalMs === 'number') ? s.globalMinIntervalMs : (typeof cd.globalMinIntervalMs === 'number' ? cd.globalMinIntervalMs : '');
        if ($('globalMinIntervalMs')) $('globalMinIntervalMs').value = (gms === '' ? '' : String(gms));
        if ($('cdSameLong')) $('cdSameLong').value = (typeof same.LONG === 'number' ? String(same.LONG) : '');
        if ($('cdSameShort')) $('cdSameShort').value = (typeof same.SHORT === 'number' ? String(same.SHORT) : '');
        if ($('cdOppLong')) $('cdOppLong').value = (typeof opp.LONG === 'number' ? String(opp.LONG) : '');
        if ($('cdOppShort')) $('cdOppShort').value = (typeof opp.SHORT === 'number' ? String(opp.SHORT) : '');
        if ($('oppMinConf')) $('oppMinConf').value = (typeof s.oppositeMinConfidence === 'number' ? String(s.oppositeMinConfidence) : '');
        const by = s.oppositeMinConfidenceByDirection || {};
        if ($('oppMinConfLong')) $('oppMinConfLong').value = (typeof by.LONG === 'number' ? String(by.LONG) : '');
        if ($('oppMinConfShort')) $('oppMinConfShort').value = (typeof by.SHORT === 'number' ? String(by.SHORT) : '');
        // 新增：反向并存开关
        if ($('allowOppositeWhileOpen')) $('allowOppositeWhileOpen').checked = !!s.allowOppositeWhileOpen;
        // 新增：EV 阈值回填
        const ev = s.evThreshold || {};
        const byVol = ev.byVolatility || {};
        const byReg = ev.byRegime || {};
        if ($('evDef')) $('evDef').value = (typeof ev.default === 'number' ? String(ev.default) : '');
        if ($('evVolH')) $('evVolH').value = (typeof byVol.HIGH === 'number' ? String(byVol.HIGH) : '');
        if ($('evVolM')) $('evVolM').value = (typeof byVol.MEDIUM === 'number' ? String(byVol.MEDIUM) : '');
        if ($('evVolL')) $('evVolL').value = (typeof byVol.LOW === 'number' ? String(byVol.LOW) : '');
        if ($('evRegT')) $('evRegT').value = (typeof byReg.TREND === 'number' ? String(byReg.TREND) : '');
        if ($('evRegR')) $('evRegR').value = (typeof byReg.RANGE === 'number' ? String(byReg.RANGE) : '');
        // 清除历史校验态
        ['globalMinIntervalMs','cdSameLong','cdSameShort','cdOppLong','cdOppShort','oppMinConf','oppMinConfLong','oppMinConfShort','evDef','evVolH','evVolM','evVolL','evRegT','evRegR']
          .forEach(id => clearInvalid($(id)));
      } catch (_) {}
    }

    async function onSaveStrategyCfg() {
      ensureValidationStyle();
      const statusEl = $('saveCfgStatus');
      const btn = $('saveStrategyCfg');
      if (statusEl) { statusEl.textContent = '保存中...'; statusEl.removeAttribute('title'); }
      if (btn) btn.disabled = true;
      try {
        // 元素引用
        const eGms = $('globalMinIntervalMs');
        const eSL = $('cdSameLong');
        const eSS = $('cdSameShort');
        const eOL = $('cdOppLong');
        const eOS = $('cdOppShort');
        const eOC = $('oppMinConf');
        const eBLong = $('oppMinConfLong');
        const eBShort = $('oppMinConfShort');
        const eAllowOpp = $('allowOppositeWhileOpen');
        const eEvDef = $('evDef');
        const eEvVolH = $('evVolH');
        const eEvVolM = $('evVolM');
        const eEvVolL = $('evVolL');
        const eEvRegT = $('evRegT');
        const eEvRegR = $('evRegR');
        
        // 先清除历史校验态
        [eGms,eSL,eSS,eOL,eOS,eOC,eBLong,eBShort,eEvDef,eEvVolH,eEvVolM,eEvVolL,eEvRegT,eEvRegR].forEach(clearInvalid);
        
        // 读取开关状态
        const allowOpp = eAllowOpp ? eAllowOpp.checked : false;
        
        // 读取输入
        const gms = numOrEmpty(eGms?.value);
        const sameLong = numOrEmpty(eSL?.value);
        const sameShort = numOrEmpty(eSS?.value);
        const oppLong = numOrEmpty(eOL?.value);
        const oppShort = numOrEmpty(eOS?.value);
        const oppConf = numOrEmpty(eOC?.value);
        const byLong = numOrEmpty(eBLong?.value);
        const byShort = numOrEmpty(eBShort?.value);
        const evDef = numOrEmpty(eEvDef?.value);
        const evVolH = numOrEmpty(eEvVolH?.value);
        const evVolM = numOrEmpty(eEvVolM?.value);
        const evVolL = numOrEmpty(eEvVolL?.value);
        const evRegT = numOrEmpty(eEvRegT?.value);
        const evRegR = numOrEmpty(eEvRegR?.value);

        const payload = {};
        const warnings = [];
        let invalids = 0; // 新增：无效输入计数

        // 冷却对象
        const cooldown = {};
        if (gms !== undefined) {
          if (isNonNegInt(gms)) { cooldown.globalMinIntervalMs = gms; }
          else { warnings.push('globalMinIntervalMs 必须为非负整数'); markInvalid(eGms, '必须为非负整数'); invalids++; }
        }
        const same = {};
        if (sameLong !== undefined) {
          if (isNonNegInt(sameLong)) same.LONG = sameLong; else { warnings.push('sameDir.LONG 必须为非负整数'); markInvalid(eSL, '必须为非负整数'); invalids++; }
        }
        if (sameShort !== undefined) {
          if (isNonNegInt(sameShort)) same.SHORT = sameShort; else { warnings.push('sameDir.SHORT 必须为非负整数'); markInvalid(eSS, '必须为非负整数'); invalids++; }
        }
        if (Object.keys(same).length) cooldown.sameDir = same;

        const opp = {};
        if (oppLong !== undefined) {
          if (isNonNegInt(oppLong)) opp.LONG = oppLong; else { warnings.push('opposite.LONG 必须为非负整数'); markInvalid(eOL, '必须为非负整数'); invalids++; }
        }
        if (oppShort !== undefined) {
          if (isNonNegInt(oppShort)) opp.SHORT = oppShort; else { warnings.push('opposite.SHORT 必须为非负整数'); markInvalid(eOS, '必须为非负整数'); invalids++; }
        }
        if (Object.keys(opp).length) cooldown.opposite = opp;

        if (Object.keys(cooldown).length) payload.cooldown = cooldown;

        // 反向置信度
        if (oppConf !== undefined) {
          if (isProb(oppConf)) payload.oppositeMinConfidence = oppConf; else { warnings.push('oppositeMinConfidence 必须在 0~1 区间'); markInvalid(eOC, '必须在 [0,1]'); invalids++; }
        }
        const by = {};
        if (byLong !== undefined) {
          if (isProb(byLong)) by.LONG = byLong; else { warnings.push('byDirection.LONG 必须在 0~1 区间'); markInvalid(eBLong, '必须在 [0,1]'); invalids++; }
        }
        if (byShort !== undefined) {
          if (isProb(byShort)) by.SHORT = byShort; else { warnings.push('byDirection.SHORT 必须在 0~1 区间'); markInvalid(eBShort, '必须在 [0,1]'); invalids++; }
        }
        if (Object.keys(by).length) payload.oppositeMinConfidenceByDirection = by;

        // 反向并存开关：始终下发（后端做布尔解析）
        if (eAllowOpp) payload.allowOppositeWhileOpen = allowOpp;

        // evThreshold
        const evObj = {};
        if (evDef !== undefined) { if (isFiniteNum(evDef)) evObj.default = evDef; else { warnings.push('evThreshold.default 必须为数值'); markInvalid(eEvDef, '必须为数值'); invalids++; } }
        const bv = {};
        if (evVolH !== undefined) { if (isFiniteNum(evVolH)) bv.HIGH = evVolH; else { warnings.push('evThreshold.byVolatility.HIGH 必须为数值'); markInvalid(eEvVolH, '必须为数值'); invalids++; } }
        if (evVolM !== undefined) { if (isFiniteNum(evVolM)) bv.MEDIUM = evVolM; else { warnings.push('evThreshold.byVolatility.MEDIUM 必须为数值'); markInvalid(eEvVolM, '必须为数值'); invalids++; } }
        if (evVolL !== undefined) { if (isFiniteNum(evVolL)) bv.LOW = evVolL; else { warnings.push('evThreshold.byVolatility.LOW 必须为数值'); markInvalid(eEvVolL, '必须为数值'); invalids++; } }
        if (Object.keys(bv).length) evObj.byVolatility = bv;
        const br = {};
        if (evRegT !== undefined) { if (isFiniteNum(evRegT)) br.TREND = evRegT; else { warnings.push('evThreshold.byRegime.TREND 必须为数值'); markInvalid(eEvRegT, '必须为数值'); invalids++; } }
        if (evRegR !== undefined) { if (isFiniteNum(evRegR)) br.RANGE = evRegR; else { warnings.push('evThreshold.byRegime.RANGE 必须为数值'); markInvalid(eEvRegR, '必须为数值'); invalids++; } }
        if (Object.keys(br).length) evObj.byRegime = br;
        if (Object.keys(evObj).length) payload.evThreshold = evObj;

        // 一致性提示：同时设置全局与分方向
        if (payload.oppositeMinConfidence != null && payload.oppositeMinConfidenceByDirection != null) {
          warnings.push('提示：已同时设置全局和分方向置信度，分方向将覆盖对应方向');
        }

        // 若存在无效输入，阻止提交
        if (invalids > 0) {
          if (statusEl) {
            statusEl.textContent = `存在无效输入 ${invalids} 处，已高亮，请修正后再保存`;
            statusEl.title = warnings.join('\n');
          }
          return;
        }

        // 如果没有有效字段
        if (!Object.keys(payload).length) {
          if (statusEl) { statusEl.textContent = '没有可保存的改动'; statusEl.removeAttribute('title'); }
          return;
        }

        // 发送
        const resp = await fetch(resolveApiUrl('/api/config'), {
          method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
        });
        const json = await resp.json().catch(() => ({}));
        const ok = !!json?.success || resp.ok;
        let msg = ok ? '已保存' : `保存失败：${json?.error || resp.status}`;
        if (Array.isArray(json?.warnings) && json.warnings.length) {
          msg += `（后端警告 ${json.warnings.length} 条）`;
        }
        if (warnings.length) {
          msg += `（前端警告 ${warnings.length} 条）`;
          console.warn('local warnings:', warnings);
        }
        if (statusEl) { statusEl.textContent = msg; statusEl.title = warnings.concat(json?.warnings||[]).join('\n'); }
        if (ok) {
          // 保存成功后，刷新一次以显示最新值
          try { await load(); } catch (_) {}
        }
      } catch (e) {
        const statusEl = $('saveCfgStatus');
        if (statusEl) statusEl.textContent = `保存异常：${e?.message || String(e)}`;
      } finally {
        const btn = $('saveStrategyCfg');
        if (btn) btn.disabled = false;
      }
    }


     async function load() {
      if (loading) return; // 防重入
      loading = true;
      setLoadingUI(true);
      setBadge('tickerStatus', 'warn', '加载中…');
      setBadge('klineStatus', 'warn', '加载中…');
      setBadge('indStatus', 'warn', '加载中…');
      setBadge('analysisStatus', 'warn', '加载中…');
      setBadge('perfStatus', 'warn', '加载中…');
      setBadge('configStatus', 'warn', '加载中…');
      setBadge('svcStatus', 'warn', '加载中…');

      // 新增：每次刷新生成新的控制器，并中断上一轮未完成请求
      if (currentLoadCtrl) { try { currentLoadCtrl.abort(new Error('NewLoad')); } catch (_) {} }
      currentLoadCtrl = new AbortController();
      const extSignal = currentLoadCtrl.signal;

      const symbol = $('symbol').value.trim();
      const interval = $('interval').value;
      const limit = parseInt($('limit').value) || 120;
      try {

        // 第一批：先拿诊断（较重），其余接口稍后发，避免瞬时尖峰
        const diagResp = await getJson(`/api/diagnostics/validate?symbol=${encodeURIComponent(symbol)}&interval=${encodeURIComponent(interval)}&limit=${limit}`, 20000, 1, { signal: extSignal });
        const diag = (diagResp && typeof diagResp === 'object' && 'data' in diagResp) ? (diagResp.data || {}) : diagResp;

        // 先落入原始数据及部分渲染
        rawPayloads.diag = diag;
        rawPayloads.indicators = diag?.indicators;
        rawPayloads.svc = { health: diag?.health, performance: diag?.performance, cache: diag?.cache };

        // 新增：指标兜底（当样本不足或计算失败导致无 current 时，尝试从 /api/indicators/latest 获取）
        try {
          if (!diag?.indicators || !diag.indicators.current) {
            const latest = await getJson(`/api/indicators/latest?symbol=${encodeURIComponent(symbol)}&interval=${encodeURIComponent(interval)}&limit=${Math.max(120, limit)}`, 15000, 1, { signal: extSignal });
            const latestData = latest?.data;
            if (latestData && typeof latestData === 'object') {
              diag.indicators = { issues: (diag?.indicators?.issues || []), current: latestData };
              rawPayloads.indicators = diag.indicators;
            }
          }
        } catch (_) { /* 忽略兜底失败，不影响后续渲染 */ }

        // 先用 diag 渲染 K线与服务卡片，指标卡片先做部分渲染
        let ticker = null;
        let k24 = null;
        renderKlineCard(diag, ticker, k24);
        renderIndCard(diag, ticker, k24);
        renderSvcCard(diag);

        // 第二批：并发请求其余接口，分别完成分别渲染
        const analysisP = (async () => {
          try {
            const res = await getJson('/api/strategy/analysis', 15000, 1, { signal: extSignal });
            rawPayloads.analysis = res;
            const a = res?.data ?? null;
            // 统一渲染：即使无数据也渲染骨架字段
            const s = a?.signal || {};
            const rec = a?.recommendation || {};
            const strength = (typeof s?.strength?.combined === 'number')
              ? (s.strength.combined / 100)
              : (typeof s?.strength === 'number' ? s.strength : null);
            const confidence = (typeof s?.strength?.confidence === 'number')
              ? s.strength.confidence
              : (typeof rec?.confidence === 'number' ? rec.confidence : (typeof s?.confidence === 'number' ? s.confidence : null));
            kv($('analysisKv'), {
              '状态 Status': a ? '就绪' : '暂无数据',
              '信号类型 Signal Type': s.signal || rec.action || '—',
              '信号强度 Signal Strength': (typeof strength === 'number') ? pct(strength) : '—',
              '置信度 Confidence': (typeof confidence === 'number') ? pct(confidence) : '—',
              '建议动作 Recommendation': rec.action || '—',
              '建议紧迫度 Urgency': rec.urgency || '—',
              '时间框 Timeframe': s.timeframe || rec.timeframe || '—',
              '目标价 Target Price': (typeof s.targetPrice === 'number') ? s.targetPrice.toFixed(2) : '—',
              '止损 Stop Loss': (typeof s.stopLoss === 'number') ? s.stopLoss.toFixed(2) : '—',
              '止盈 Take Profit': (typeof s.takeProfit === 'number') ? s.takeProfit.toFixed(2) : '—',
              '风险分数 Risk Score': (typeof a?.riskManagement?.riskScore === 'number') ? a.riskManagement.riskScore.toFixed(2) : '—',
              '杠杆 Leverage': (typeof a?.riskManagement?.leverage === 'number') ? String(a.riskManagement.leverage) : '—',
              '预期胜率 Expected Win Rate': (typeof a?.performance?.expectedWinRate === 'number') ? pct(a.performance.expectedWinRate) : '—',
              '风险回报 Risk/Reward': (typeof a?.performance?.riskRewardRatio === 'number') ? a.performance.riskRewardRatio.toFixed(2) : '—'
            });
            setBadge('analysisStatus', a ? 'ok' : 'warn', a ? '已更新' : '暂无数据');
          } catch (err) {
            rawPayloads.analysis = { error: err?.message || String(err || 'unknown error') };
            setBadge('analysisStatus', 'err', `错误：${String(err?.message || err).slice(0,80)}`);
          }
        })();

        const perfP = (async () => {
          try {
            const res = await getJson('/api/strategy/performance', 15000, 1, { signal: extSignal });
            rawPayloads.perf = res;
            const p = res?.data || {};
            kv($('perfKv'), {
              '累计收益率 Total PnL%': (typeof p.totalPnlPercent === 'number') ? pctp(p.totalPnlPercent) : '—',
              '胜率 Win Rate': (typeof p.winRate === 'number') ? pct(p.winRate) : '—',
              '利润因子 Profit Factor': p.profitFactor ?? '—',
              '夏普比率 Sharpe Ratio': p.sharpeRatio ?? '—',
              '最大回撤 Max Drawdown': (typeof p.maxDrawdown === 'number') ? pct(p.maxDrawdown) : '—',
              '总交易次数 Total Trades': p.totalTrades ?? '—',
              '最后更新时间 Last Updated': (p.lastUpdated != null) ? `${fmtTs(p.lastUpdated)} (${p.lastUpdated})` : '—'
            });
            setBadge('perfStatus', 'ok', '已更新');
          } catch (err) {
            rawPayloads.perf = { error: err?.message || String(err || 'unknown error') };
            setBadge('perfStatus', 'err', `错误：${String(err?.message || err).slice(0,80)}`);
          }
        })();

        const cfgP = (async () => {
          try {
            const res = await getJson('/api/config', 15000, 0, { signal: extSignal });
            rawPayloads.cfg = res;
            const c = res?.data || {};
            kv($('configKv'), {
              '交易标的 Symbol': c?.trading?.defaultSymbol || '—',
              '最大杠杆 Max Leverage': c?.trading?.maxLeverage ?? '—',
              '单日亏损限制 Daily Loss Limit': (typeof c?.risk?.maxDailyLoss === 'number') ? pct(c.risk.maxDailyLoss) : '—',
              '止损 Stop Loss': (typeof c?.risk?.stopLossPercent === 'number') ? pct(c.risk.stopLossPercent) : '—',
              '止盈 Take Profit': (typeof c?.risk?.takeProfitPercent === 'number') ? pct(c.risk.takeProfitPercent) : '—',
              '信号阈值 Signal Threshold': (typeof c?.strategy?.signalThreshold === 'number') ? c.strategy.signalThreshold : '—',
              '手续费 Commission': (typeof c?.commission === 'number') ? pct(c.commission) : '—',
              '滑点 Slippage': (typeof c?.slippage === 'number') ? pct(c.slippage) : '—',
              'Web端口 Web Port': c?.webServer?.port ?? '—',
              '代理地址 Proxy URL': c?.proxy?.url || '—',
              '已启用代理 Proxy Enabled': c?.proxy?.enabled ? 'true' : 'false'
            });
            // 新增：将获取到的策略冷却/置信度填入编辑框
            try { fillStrategyEdit(c?.strategy || {}); } catch (_) {}
            setBadge('configStatus', 'ok', '已更新');
          } catch (err) {
            rawPayloads.cfg = { error: err?.message || String(err || 'unknown error') };
            setBadge('configStatus', 'err', `错误：${String(err?.message || err).slice(0,80)}`);
          }
        })();

        // ticker 与 k24：完成即渲染，并推动指标卡片的补全
        const tickerP = (async () => {
          try {
            const res = await getJson(`/api/market/ticker?symbol=${encodeURIComponent(symbol)}`, 15000, 1, { signal: extSignal });
            ticker = res;
            rawPayloads.ticker = res;
            if (res && res.data) {
              renderTickerCard(res.data, 'ok', '已更新');
              // K线卡片中均量的美元估算可能依赖价格，得到后再刷新一次
              renderKlineCard(diag, ticker, k24);
              // 指标卡片补全 24h 对比
              renderIndCard(diag, ticker, k24);
            }
          } catch (err) {
            // 使用回退数据：优先 crossChecks.tickerPrice 其次 lastClose
            const fallbackPrice = (typeof (diag?.crossChecks?.tickerPrice) === 'number')
              ? diag.crossChecks.tickerPrice
              : (typeof (diag?.crossChecks?.lastClose) === 'number' ? diag.crossChecks.lastClose : undefined);
            const fallback = { price: fallbackPrice, change24h: undefined, timestamp: Date.now() };
            rawPayloads.tickerFallback = { reason: err?.message || 'unavailable', used: fallback };
            renderTickerCard(fallback, 'warn', '使用备用价格');
            // 新增：使用回退价格刷新 K线卡片与指标卡片，补全依赖价格的估算项
            try {
              renderKlineCard(diag, fallback, k24);
              renderIndCard(diag, fallback, k24);
            } catch (_) {}
          }
        })();

        const k24Url = `/api/market/kline?symbol=${encodeURIComponent(symbol)}&interval=1H&limit=25`;
        const k24P = (async () => {
          try {
            const res = await getJson(k24Url, 18000, 1, { signal: extSignal });
            k24 = res;
            // 补充到服务原始数据
            rawPayloads.svc = { ...(rawPayloads.svc||{}), kline24h: res };
            // 指标卡片补全 24h 对比
            renderIndCard(diag, ticker, k24);
            // 新增：获取k24后刷新K线卡片
            renderKlineCard(diag, ticker, k24);
          } catch (err) {
            // 标记但不中断整体流程
            rawPayloads.svc = { ...(rawPayloads.svc||{}), kline24h: { error: err?.message || String(err||'unknown error') } };
            renderIndCard(diag, ticker, null);
          }
        })();

        // 等待所有并发项结束后，再进行聚合原始数据与“上次更新”标记
        await Promise.allSettled([analysisP, perfP, cfgP, tickerP, k24P]);

        // 聚合原始
        const ric = window.requestIdleCallback || ((fn) => setTimeout(fn, 200));
        ric(() => {
          if (currentLoadCtrl && currentLoadCtrl.signal !== extSignal) return; // 新一轮刷新则放弃
          const all = { diag, analysis: rawPayloads.analysis, perf: rawPayloads.perf, cfg: rawPayloads.cfg, ticker, k24 };
          rawPayloads.all = all;
          $('allRaw').textContent = JSON.stringify(all, null, 2);
        });

        setLastUpdated(Date.now());
      } catch (e) {
        console.error(e);
        // 改为顶部状态显示，而非弹窗
        setLastUpdated(null);
        setBadge('tickerStatus', 'err', '加载失败');
        setBadge('klineStatus', 'err', '加载失败');
        setBadge('indStatus', 'err', '加载失败');
        setBadge('analysisStatus', 'err', '加载失败');
        setBadge('perfStatus', 'err', '加载失败');
        setBadge('configStatus', 'err', '加载失败');
        setBadge('svcStatus', 'err', '加载失败');
      } finally {
        loading = false;
        setLoadingUI(false);
        // 自动刷新倒计时
        if ($('auto').checked) startCountdown(autoIntervalMs);
        // 若本次控制器仍是当前控制器，则释放
        if (currentLoadCtrl && extSignal === currentLoadCtrl.signal) {
          currentLoadCtrl = null;
        }
       }
     }

    $('refresh').onclick = load;
    $('auto').onchange = function() {
      if (this.checked) {
        if (timer) clearInterval(timer);
        timer = setInterval(load, autoIntervalMs);
        startCountdown(autoIntervalMs);
      } else if (timer) {
        clearInterval(timer);
        clearInterval(countdownTimer);
        $('countdown').textContent = '';
        timer = null;
      }
    };

    window.onload = () => {
      // 绑定 details 的延迟渲染
      bindLazyForPre('tickerRaw', 'ticker');
      bindLazyForPre('klineRaw', 'diag');
      bindLazyForPre('indRaw', 'indicators');
      bindLazyForPre('analysisRaw', 'analysis');
      bindLazyForPre('perfRaw', 'perf');
      bindLazyForPre('configRaw', 'cfg');
      bindLazyForPre('svcRaw', 'svc');

      // 新增：绑定保存按钮
      const btn = document.getElementById('saveStrategyCfg');
      if (btn) {
        btn.onclick = onSaveStrategyCfg;
      }
      // 新增：绑定输入实时校验
      try { attachStrategyInputValidation(); } catch (_) {}
    
      load();
      timer = setInterval(load, autoIntervalMs);
      startCountdown(autoIntervalMs);
    };  </script>
</body>
</html>
