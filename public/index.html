<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ETH Agent合约策略分析系统</title>
    <link rel="icon" type="image/svg+xml" href="/eth-logo.svg" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            max-width: 1680px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        
        .header h1 {
            font-size: 3em;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 15px;
        }
        
        .header p {
            font-size: 1.2em;
            color: #666;
            margin-bottom: 30px;
        }
        
        .status-bar {
            display: flex;
            justify-content: center;
            gap: 30px;
            flex-wrap: wrap;
        }
        
        .status-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 20px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 25px;
            border: 2px solid rgba(102, 126, 234, 0.2);
        }
        
        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #27ae60;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 25px;
            margin-bottom: 30px;
            max-width: 1680px;
            margin-left: auto;
            margin-right: auto;
        }
        
        .card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            transition: transform 0.3s, box-shadow 0.3s;
        }
        
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 30px 60px rgba(0,0,0,0.15);
        }
        
        .card h2 {
            font-size: 1.5em;
            margin-bottom: 20px;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .card-icon {
            width: 22px;
            height: 22px;
            display: inline-block;
            vertical-align: -4px;
            background: none;
        }
        
        .metric-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .metric {
            text-align: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        
        .metric-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 5px;
        }
        
        /* 加载占位：字体小且淡黄色 */
        .metric-value.loading-inline {
            font-size: 1.2em;
            color: #f6e58d;
        }
        
        .metric-label {
            font-size: 0.9em;
            color: #7f8c8d;
        }
        
        .btn {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s;
            text-decoration: none;
            display: inline-block;
            text-align: center;
            margin: 5px;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(52, 152, 219, 0.3);
        }
        
        /* 顶部右侧诊断面板按钮 */
        .inspect-fab {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }
        
        .btn-success {
            background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
        }
        
        .btn-warning {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }

        /* 独立气泡透明按钮（不依赖 .btn） */
        .bubble-btn{position:relative;display:inline-flex;align-items:center;justify-content:center;height:40px;padding:0 16px;border-radius:12px;border:1px solid rgba(255,255,255,.35);background:rgba(255,255,255,.06);backdrop-filter:blur(10px);-webkit-backdrop-filter:blur(10px);color:#ffffff;text-shadow:0 1px 2px rgba(0,0,0,.35);font-weight:600;letter-spacing:.2px;cursor:pointer;outline:none;transition:transform .2s ease, box-shadow .3s ease, background .3s ease, border-color .3s ease, color .3s ease;box-shadow:inset 0 1px 0 rgba(255,255,255,.2), 0 4px 16px rgba(46,126,255,.18);}
        .bubble-btn .label{position:relative;z-index:2}
        .bubble-btn .ring{position:absolute;inset:-2px;border-radius:inherit;padding:1px;background:conic-gradient(from 0deg,#79c0ff,#a78bfa,#60a5fa,#79c0ff);mask:linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);-webkit-mask:linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);-webkit-mask-composite:xor;mask-composite:exclude;opacity:.9;transition:opacity .3s ease, filter .3s ease;filter:blur(.5px);}
        .bubble-btn::before{content:"";position:absolute;inset:0;border-radius:inherit;background:radial-gradient(120% 60% at 30% 10%, rgba(255,255,255,.45), rgba(255,255,255,.1) 60%, transparent 70%), radial-gradient(120% 80% at 70% 120%, rgba(59,130,246,.25), transparent 60%);z-index:1;}
        .bubble-btn::after{content:"";position:absolute;left:10px;top:6px;width:10px;height:10px;border-radius:50%;background:rgba(255,255,255,.85);filter:blur(1px);opacity:.9;z-index:2;}
        .bubble-btn:hover{transform:translateY(-2px);box-shadow:inset 0 1px 0 rgba(255,255,255,.25), 0 8px 24px rgba(46,126,255,.25);background:rgba(255,255,255,.08);color:#e2e8f0;}
        .bubble-btn:active{transform:translateY(0);box-shadow:inset 0 2px 6px rgba(0,0,0,.25), 0 4px 12px rgba(46,126,255,.25);}
        .bubble-btn:focus-visible{outline:2px solid rgba(125,211,252,.6);outline-offset:2px}
        .bubble-btn.disabled, .bubble-btn:disabled{opacity:.6;cursor:not-allowed;box-shadow:none;}
        .bubble-btn .ring{animation:spin 3.8s linear infinite;}
        @keyframes spin{to{transform:rotate(360deg)}}

        /* 灰暗禁用态 */
        .btn:disabled, .btn.disabled {
            background: linear-gradient(135deg, #bdc3c7 0%, #95a5a6 100%) !important;
            box-shadow: none !important;
            transform: none !important;
            cursor: not-allowed;
            color: #ffffff !important;
            opacity: 1 !important;
        }
        .btn-success:disabled, .btn-danger:disabled {
            background: linear-gradient(135deg, #bdc3c7 0%, #95a5a6 100%) !important;
        }
        
        .signal-display {
            padding: 20px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 15px;
            margin-bottom: 20px;
        }
        
        .signal-strength {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .strength-bar {
            flex: 1;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .strength-fill {
            height: 100%;
            background: linear-gradient(90deg, #27ae60 0%, #f39c12 50%, #e74c3c 100%);
            transition: width 0.3s;
        }
        
        .footer {
            text-align: center;
            padding: 30px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            margin-top: 30px;
        }
        
        .footer p {
            color: #7f8c8d;
            margin-bottom: 15px;
        }
        
        .footer-links {
            display: flex;
            justify-content: center;
            gap: 30px;
            flex-wrap: wrap;
        }
        
        .footer-links a {
            color: #3498db;
            text-decoration: none;
            font-weight: 600;
            transition: color 0.3s;
        }
        
        .footer-links a:hover {
            color: #2980b9;
        }
        
        .loading {
            text-align: center;
            padding: 20px;
            color: #7f8c8d;
        }
        
        .error {
            background: #e74c3c;
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
        }
        /* 新增：推荐卡片样式 */
        .trading-recommendation {
            padding: 15px;
            background: #f8f9fa;
            border-radius: 12px;
            margin-bottom: 12px;
            border: 1px solid #eef2f7;
        }
        .trading-recommendation .row {
            display: flex;
            justify-content: space-between;
            margin: 6px 0;
            font-size: 14px;
            color: #555;
        }
        .trading-recommendation .key { color: #7f8c8d; }
        .trading-recommendation .val { color: #2c3e50; font-weight: 600; }
        .trading-buttons { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }
        
        /* 推荐历史样式 */
        .recommendation-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            align-items: center;
        }
        
        .recommendation-controls select {
            padding: 6px 10px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            background: white;
            font-size: 14px;
        }
        
        .btn-sm {
            padding: 6px 12px;
            font-size: 14px;
            color: #ffffff;
        }
        
        .recommendation-list {
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 15px;
        }
        
        .recommendation-item {
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            background: #f9fafb;
            transition: all 0.2s;
        }
        
        .recommendation-item:hover {
            background: #f3f4f6;
            border-color: #d1d5db;
        }
        
        /* 推荐表格样式 */
        .recommendation-table-container {
            overflow-x: auto;
            margin-bottom: 20px;
        }
        
        .recommendation-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }
        
        .recommendation-table th,
        .recommendation-table td {
            padding: 12px 8px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }
        
        .recommendation-table th {
            background-color: #f8f9fa;
            font-weight: 600;
            color: #2c3e50;
            position: sticky;
            top: 0;
        }
        
        .recommendation-table tr:hover {
            background-color: #f8f9fa;
        }
        
        .recommendation-row.pending {
            background-color: #fff3cd;
        }
        
        .recommendation-row.active {
            background-color: #d1ecf1;
        }
        
        .recommendation-row.closed {
            background-color: #d4edda;
        }
        
        .recommendation-row.expired {
            background-color: #f8d7da;
        }
        
        .action-badge {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .action-badge.long {
            background-color: #d4edda;
            color: #155724;
        }
        
        .action-badge.short {
            background-color: #f8d7da;
            color: #721c24;
        }
        
        .action-badge.hold {
            background-color: #fff3cd;
            color: #856404;
        }
        
        .status-badge {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }
        
        .status-badge.pending {
            background-color: #fff3cd;
            color: #856404;
        }
        
        .status-badge.active {
            background-color: #cce5ff;
            color: #004085;
        }
        
        .status-badge.closed {
            background-color: #d4edda;
            color: #155724;
        }
        
        .status-badge.expired {
            background-color: #f8d7da;
            color: #721c24;
        }
        
        /* 新增：出场原因小徽标 */
        .reason-badge {
            display: inline-block;
            margin-left: 6px;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 11px;
            color: #374151;
            background: #eef2ff;
            border: 1px solid #e5e7eb;
            vertical-align: middle;
            line-height: 1;
        }
        
        .pnl-value.positive {
            color: #28a745;
            font-weight: 600;
        }
        
        .pnl-value.negative {
            color: #dc3545;
            font-weight: 600;
        }
        
        .recommendation-item.active {
            border-color: #3b82f6;
            background: #eff6ff;
        }
        
        .recommendation-item.completed {
            border-color: #10b981;
            background: #ecfdf5;
        }
        
        .recommendation-item.stopped {
            border-color: #ef4444;
            background: #fef2f2;
        }
        
        .recommendation-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .recommendation-action {
            font-weight: 600;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .recommendation-action.LONG {
            background: #dcfce7;
            color: #166534;
        }
        
        .recommendation-action.SHORT {
            background: #fee2e2;
            color: #991b1b;
        }
        
        .recommendation-action.HOLD {
            background: #f3f4f6;
            color: #374151;
        }
        
        .recommendation-time {
            font-size: 12px;
            color: #6b7280;
        }
        
        .recommendation-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 8px;
            font-size: 13px;
        }
        
        .recommendation-detail {
            display: flex;
            justify-content: space-between;
        }
        
        .recommendation-detail .label {
            color: #6b7280;
        }
        
        .recommendation-detail .value {
            font-weight: 500;
        }
        
        .recommendation-pnl {
            font-weight: 600;
        }
        
        .recommendation-pnl.positive {
            color: #10b981;
        }
        
        .recommendation-pnl.negative {
            color: #ef4444;
        }
        
        .recommendation-stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            padding: 15px;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }
        
        .stat-item {
            text-align: center;
        }
        
        .stat-value {
            display: block;
            font-size: 18px;
            font-weight: 600;
            color: #1f2937;
        }
        
        .stat-label {
            display: block;
            font-size: 12px;
            color: #6b7280;
            margin-top: 4px;
        }
        
        .success {
            background: #27ae60;
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
        }
        
        /* 新增：行情卡片内联状态提示 */
        .inline-status { display: inline-block; font-size: 12px; color: #7f8c8d; margin-top: 8px; }
        .inline-status.ok { color: #27ae60; }
        .inline-status.warn { color: #f39c12; }
        .inline-status.err { color: #e74c3c; }
        .card h2 .inline-status { margin-left: auto; margin-top: 0; }
        
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .status-bar {
                gap: 15px;
            }
            
            .main-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .metric-grid {
                grid-template-columns: 1fr;
            }
        }
        /* 分页样式 */
        .pagination{display:flex;align-items:center;gap:8px;justify-content:flex-end;margin:8px 0 16px}
        .pagination .page-btn,.pagination .page-number{padding:6px 10px;border:1px solid #d1d5db;background:#fff;border-radius:6px;cursor:pointer;font-size:13px}
        .pagination .page-number.active{background:#3498db;color:#fff;border-color:#3498db}
        .pagination .page-btn[disabled]{opacity:.5;cursor:not-allowed}
        .pagination .page-info{margin-left:8px;color:#6b7280;font-size:12px}
        /* FGI 半圆仪表盘样式 */
        .section-sep{height:1px;background:linear-gradient(90deg,rgba(255,255,255,0),rgba(148,163,184,.35) 15%,rgba(148,163,184,.35) 85%,rgba(255,255,255,0));margin:10px 0 12px}
        .fgi-header{font-size:14px;color:#6b7280;letter-spacing:.4px;margin:-2px 0 2px}
        .fgi-gauge{display:flex;flex-direction:column;align-items:center;justify-content:center;padding:6px 0 2px}
        .fgi-gauge svg{width:100%;max-width:420px;height:200px;overflow:visible}
        .fgi-track{fill:none;stroke:#e5e7eb;stroke-width:14;opacity:.45}
        .fgi-arc{fill:none;stroke-width:14;stroke-linecap:butt;opacity:1;transition:opacity .3s ease;stroke-dasharray:18 82}
        /* 五等分+空白分隔：每段18% + 2%间隔，起点分别为 0/20/40/60/80 */
        #arc-red{stroke-dashoffset:0}
         #arc-orange{stroke-dashoffset:-20.5}
         #arc-yellow{stroke-dashoffset:-41}
         #arc-green{stroke-dashoffset:-61.5}
         #arc-darkgreen{stroke-dashoffset:-82}
        .fgi-dot{filter:drop-shadow(0 2px 4px rgba(0,0,0,.35));transition:cx .5s cubic-bezier(.22,1,.36,1), cy .5s cubic-bezier(.22,1,.36,1);fill:#fff;stroke:#0f172a;stroke-width:3}
        .fgi-value{font-size:40px;font-weight:800;color:#111827;margin-top:-10px;text-shadow:0 1px 1px rgba(0,0,0,.07)}
        .fgi-label{font-size:13px;color:#6b7280;margin-top:4px}
        .fgi-legend{font-size:12px;color:#9ca3af;margin-top:2px}
        
        /* 条件参数按钮样式 */
        .conditions-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }
        
        .conditions-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        
        .conditions-btn:active {
            transform: translateY(0);
        }
    </style>
</head>
<body>
    <div class="inspect-fab">
        <button class="bubble-btn" onclick="openInspect()"><span class="label">数据与指标诊断面板</span><span class="ring"></span></button>
    </div>
    <div class="container">
        <div class="header">
            <h1 style="display:flex;align-items:center;gap:10px;justify-content:center">
                <img src="/eth-logo.svg" alt="ETH" width="36" height="36" style="transform: translateY(4px);"/>
                 ETH Agent合约策略分析系统
             </h1>
            <p>基于机器学习的AI Agent量化交易策略分析平台</p>
            
            <div class="status-bar">
                <div class="status-item">
                    <div class="status-dot"></div>
                    <span>系统运行中</span>
                </div>
                <div class="status-item">
                    <div class="status-dot"></div>
                    <span>策略引擎</span>
                </div>
                 <div class="status-item">
                    <div class="status-dot"></div>
                    <span>Kronos模型</span>
                </div>
                <div class="status-item">
                    <div class="status-dot"></div>
                    <span>ML分析</span>
                </div>
                <div class="status-item">
                    <div class="status-dot"></div>
                    <span>风险管理</span>
                </div>
            </div>
        </div>
        <!-- 移除交易成本信息 -->
        <div id="costInfo" style="display:none"></div>
        <div class="main-grid">
            <!-- 市场数据 -->
            <div class="card">
                <h2><span class="card-icon">💹</span>市场数据 <span id="marketInlineStatus" class="inline-status warn"></span></h2>
                <div class="metric-grid">
                    <div class="metric">
                        <div class="metric-value" id="currentPrice">--</div>
                        <div class="metric-label">当前价格</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="priceChange">--</div>
                        <div class="metric-label">今日涨跌幅(UTC+8)</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="volume">--</div>
                        <div class="metric-label">24h成交额(按张折算, USDT)</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="volatility">--</div>
                        <div class="metric-label">振幅</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="lowHigh24h">--</div>
                        <div class="metric-label">24h最低/最高</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="fundingRate">--</div>
                        <div class="metric-label">资金费率(8h)</div>
                    </div>
                </div>
                <div class="section-sep"></div>
                <div class="fgi-header">恐惧贪婪指数</div>
                <div class="fgi-gauge" id="fgiGauge">
                    <svg viewBox="0 0 200 100" preserveAspectRatio="xMidYMid meet">
                        <path class="fgi-track" d="M10,100 A90,90 0 0 1 190,100"/>
                        <path class="fgi-arc" id="arc-red" d="M10,100 A90,90 0 0 1 190,100" stroke="#b91c1c" pathLength="100"/>
                         <path class="fgi-arc" id="arc-orange" d="M10,100 A90,90 0 0 1 190,100" stroke="#ef4444" pathLength="100"/>
                         <path class="fgi-arc" id="arc-yellow" d="M10,100 A90,90 0 0 1 190,100" stroke="#facc15" pathLength="100"/>
                         <path class="fgi-arc" id="arc-green" d="M10,100 A90,90 0 0 1 190,100" stroke="#10b981" pathLength="100"/>
                         <path class="fgi-arc" id="arc-darkgreen" d="M10,100 A90,90 0 0 1 190,100" stroke="#065f46" pathLength="100" style="stroke-dasharray:18.05 81.95"/>
                        <circle id="fgiDot" class="fgi-dot" cx="100" cy="100" r="8" />
                    </svg>
                    <div class="fgi-value" id="fgiValue">--</div>
                    <div class="fgi-label" id="fgiLabel">中性</div>
                </div>
            </div>
            <!-- 开单推荐 -->
            <div class="card">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2><span class="card-icon" style="background:none !important;">🎯</span>开单推荐</h2>
                    <button class="conditions-btn" onclick="openConditionsPage()" title="查看推荐条件">
                        ⚙️ 条件参数
                    </button>
                </div>
                <div class="trading-recommendation" id="tradingRecommendation">
                    <div class="loading">正在获取推荐信号...</div>
                </div>
                <div class="metric-grid">
                    <div class="metric">
                        <div class="metric-value" id="recommendedAction">--</div>
                        <div class="metric-label">推荐操作</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="entryPrice">--</div>
                        <div class="metric-label">入场价位</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="recommendedLeverage">--</div>
                        <div class="metric-label">推荐杠杆</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="positionSizeRecommend">--</div>
                        <div class="metric-label">置信度</div>
                    </div>
                </div>
                <div class="trading-buttons">
                    <button id="btnLong" class="btn btn-success" onclick="openLongPosition()">📈 做多 (LONG)</button>
                    <button id="btnShort" class="btn btn-danger" onclick="openShortPosition()">📉 做空 (SHORT)</button>
                </div>
                <div style="margin-top: 15px; font-size: 12px; color: #666; text-align: center;">
                    建议仅供参考，请注意风险控制
                </div>
            </div>

            <!-- 推荐历史 -->
            <div class="card">
                <h2><span class="card-icon">📋</span>推荐历史 <span id="recommendationInlineStatus" class="inline-status warn"></span></h2>
                
                <!-- 筛选和排序控件 -->
                <div class="recommendation-controls">
                    <select id="statusFilter" onchange="filterRecommendations()">
                        <option value="all">全部状态</option>
                        <option value="ACTIVE">进行中</option>
                        <option value="CLOSED">已平仓</option>
                    </select>
                    
                    <select id="sortBy" onchange="sortRecommendations()">
                        <option value="created_at">按时间排序</option>
                        <option value="pnl_percent">按收益排序</option>
                        <option value="confidence_score">按置信度排序</option>
                    </select>
                    
                    <select id="sortOrder" onchange="sortRecommendations()">
                        <option value="desc">降序</option>
                        <option value="asc">升序</option>
                    </select>
                    
                    <button class="btn btn-sm" onclick="refreshRecommendations()">刷新</button>
                    <button id="deleteSelectedBtn" class="btn btn-sm btn-danger" onclick="deleteSelectedRecommendations()" disabled>删除所选(0)</button>
                </div>
                
                <div class="recommendation-table-container">
                    <table class="recommendation-table" id="recommendationTable">
                        <thead>
                            <tr>
                                <th style="width:36px;text-align:center"><input type="checkbox" id="selectAllRecs" onclick="toggleSelectAll(this)"/></th>
                                <th>时间</th>
                                <th>操作</th>
                                <th>入场价</th>
                                <th>杠杆</th>
                                <th>止盈</th>
                                <th>止损</th>
                                <th>置信度</th>
                                <th>&nbsp;&nbsp;状态</th>
                                <th>平仓价</th>
                                <th>收益</th>
                            </tr>
                        </thead>
                        <tbody id="recommendationTableBody">
                            <tr>
                                <td colspan="11" class="loading">正在加载推荐记录...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <div id="recommendationPagination" class="pagination"></div>
                <div id="timeInsights" class="time-insights"></div>
                <div class="recommendation-stats" id="recommendationStats">
                    <div class="stat-item">
                        <span class="stat-value" id="totalRecommendations">--</span>
                        <span class="stat-label">总推荐数</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="activeRecommendations">--</span>
                        <span class="stat-label">活跃中</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="winRateRecommendations">--</span>
                        <span class="stat-label">胜率</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="avgPnlRecommendations">--</span>
                        <span class="stat-label">平均收益</span>
                    </div>
                </div>
            </div>
            
            <!-- 实时策略分析 -->
            <div class="card">
                <h2><span class="card-icon">📊</span>实时策略分析</h2>
                <div id="currentSignal" class="signal-display">
                    <div class="loading">正在获取最新信号...</div>
                </div>
                <div class="metric-grid">
                    <div class="metric">
                        <div class="metric-value" id="signalStrength">--</div>
                        <div class="metric-label">信号强度</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="confidence">--</div>
                        <div class="metric-label">置信度</div>
                    </div>
                </div>
                <button class="btn" onclick="refreshSignal()">🔄 刷新信号</button>
            </div>
            
            <!-- 策略性能 -->
            <div class="card">
                <h2 style="display:flex;align-items:center;justify-content:space-between;gap:12px">
                    <span style="display:inline-flex;align-items:center;gap:8px"><span class="card-icon" style="background:none;width:auto;height:auto;line-height:1;font-size:20px">📈</span><span>策略性能</span></span>
                    <button class="bubble-btn" onclick="window.open('/backtest-report-latest.html','_blank')" title="查看回测性能报告">
                        <span class="ring" aria-hidden="true"></span>
                        <span class="label">查看报告</span>
                    </button>
                </h2>
                <div class="metric-grid">
                    <div class="metric">
                        <div class="metric-value" id="totalReturn">--</div>
                        <div class="metric-label">总收益率</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="winRate">--</div>
                        <div class="metric-label">胜率</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="sharpeRatio">--</div>
                        <div class="metric-label">夏普比率</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="maxDrawdown">--</div>
                        <div class="metric-label">最大回撤</div>
                    </div>
                </div>
                <div class="order-progress-header" style="display:flex;align-items:center;justify-content:space-between;margin-top:10px">
  <div class="metric-label" style="margin:0">策略单进度</div>
</div>
<div id="perfOrderProgressList" class="order-progress-list" style="display:flex;flex-direction:column;gap:8px;margin-top:6px"></div>
            </div>

            <!-- 滑点分析 -->
            <div class="card">
                <h2><span class="card-icon">📊</span>滑点分析 <span id="slippageInlineStatus" class="inline-status warn"></span><button id="refreshSlippageBtn" title="仅刷新滑点" style="margin-left:8px;font-size:12px;padding:4px 8px;border:1px solid #e5e7eb;border-radius:6px;background:#fff;color:#374151;cursor:pointer">刷新</button></h2>
                <div class="metric-grid">
                    <div class="metric">
                        <div class="metric-value" id="avgSlippage">--</div>
                        <div class="metric-label">平均滑点</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="maxSlippage">--</div>
                        <div class="metric-label">最大滑点</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="slippageThreshold">--</div>
                        <div class="metric-label">当前阈值</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="slippageTrend">--</div>
                        <div class="metric-label">滑点趋势</div>
                    </div>
                </div>
                
                <!-- 滑点图表容器 -->
                <div class="chart-container" style="margin: 20px 0; height: 200px; position: relative;">
                    <canvas id="slippageChart" width="400" height="200"></canvas>
                </div>
                
                <!-- 阈值调整状态 -->
                <div class="threshold-status" style="margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 8px; font-size: 14px;">
                    <div style="display: flex; align-items: center; gap: 8px; justify-content: flex-start; flex-wrap: wrap;">
                        <span>自动阈值调整:</span>
                        <span id="autoAdjustmentStatus" style="font-weight: 600; color: #166534; background:#ecfdf5; border:1px solid #bbf7d0; padding:2px 6px; border-radius:6px;">启用</span>
                    </div>
                    <div style="margin-top: 8px; font-size: 12px; color: #666;">
                        最后调整: <span id="lastAdjustmentTime">--</span>
                    </div>
                </div>
                

            </div>
            
            <!-- 风险管理 --><!-- 删除 -->
            
            <!-- 实时策略分析 --><!-- 删除 -->
            
            <!-- 回测分析 --><!-- 删除 -->
            <div class="card">
                <h2><span class="card-icon">🛡️</span>风险管理</h2>
                <div class="metric-grid">
                    <div class="metric">
                        <div class="metric-value" id="riskScore">--</div>
                        <div class="metric-label">风险评分</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="positionSize">--</div>
                        <div class="metric-label">置信度</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="stopLoss">--</div>
                        <div class="metric-label">止损价位</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="takeProfit">--</div>
                        <div class="metric-label">止盈价位</div>
                    </div>
                </div>
                <button class="btn btn-warning" onclick="viewRiskManagement()">⚙️ 风险设置</button>
            </div>

            <!-- 回测分析 -->
            <div class="card">
                <h2><span class="card-icon">🔬</span>回测分析</h2>
                <div class="metric-grid">
                    <div class="metric">
                        <div class="metric-value">历史验证</div>
                        <div class="metric-label">策略有效性</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value">多维分析</div>
                        <div class="metric-label">性能评估</div>
                    </div>
                </div>
                <a href="/backtest" class="btn"><img src="/eth-logo.svg" alt="ETH" width="16" height="16" style="vertical-align:-3px;margin-right:6px"/> 开始回测</a>
                <button class="btn btn-success" onclick="viewBacktestHistory()">📋 历史记录</button>
            </div>
        </div>
        
        <div class="footer">
            <p>ETH合约策略分析系统 - 基于机器学习的智能量化交易平台</p>
            <div class="footer-links">
                <a href="/api/strategy/status">API状态</a>
                <a href="/api/risk/status">风险管理</a>
                <a href="/backtest">回测分析</a>
                <a href="/api/config">系统配置</a>
            </div>
        </div>
    </div>
    
    <script>
        // 页面初始化后的UI调整：删除三个板块并重排顺序
        document.addEventListener('DOMContentLoaded', function() {
            try {
                const grid = document.querySelector('.main-grid');
                if (!grid) return;
                const getCardByTitle = (title) => {
                    const cards = Array.from(grid.querySelectorAll('.card'));
                    return cards.find(c => {
                        const h = c.querySelector('h2');
                        return h && h.textContent && h.textContent.includes(title);
                    });
                };
                // 删除不需要的三个板块
                ['风险管理','实时策略分析','回测分析'].forEach(t => {
                    const el = getCardByTitle(t);
                    if (el && el.parentElement === grid) el.remove();
                });
                // 确保“策略性能”在前，“推荐历史”在其后
                const perf = getCardByTitle('策略性能');
                const rec = getCardByTitle('推荐历史');
                if (grid && perf && rec && rec.previousElementSibling !== perf) {
                    grid.insertBefore(rec, perf.nextSibling);
                }
            } catch (e) {
                console.warn('UI auto adjust failed:', e);
            }
        });
        let updateInterval;
        window.__historyLoading = false;
        window.__historyPending = false;
        let lastMarketOk = false;
        let lastMarketUpdate = 0;

        // 写操作后：拦截 fetch，针对关键写接口（/api/recommendations、/api/strategy/start|stop 等）
        // 在请求成功后触发一次“立即刷新”（带去抖，避免批量删除触发多次）
        (function(){
            const _origFetch = window.fetch.bind(window);
            let _refreshTimer = null;
            function scheduleImmediateRefresh(){
                if (_refreshTimer) clearTimeout(_refreshTimer);
                _refreshTimer = setTimeout(async () => {
                    try {
                        await loadRecommendationHistory(true);
                        await updateRecommendationStats();
                    } catch (e) {
                        console.warn('即时刷新失败：', e);
                    }
                }, 150); // 150ms 去抖
            }
            function shouldTriggerImmediateRefresh(url, method){
                // 统一为大写方法
                const m = String(method || 'GET').toUpperCase();
                // 推荐相关：新增/修改/删除/关闭
                if ((m === 'POST' || m === 'PUT' || m === 'DELETE') && /\/api\/recommendations(\b|\/)/.test(url)) return true;
                // 策略启停：可能影响后续推荐生成，刷新列表/统计更直观
                if (m === 'POST' && /\/api\/strategy\/(start|stop)(\b|\/)/.test(url)) return true;
                return false;
            }
            window.fetch = async function(input, init){
                const url = (typeof input === 'string') ? input : (input && input.url ? input.url : '');
                const method = (init && init.method) || (typeof input === 'object' && input && input.method) || 'GET';
                const res = await _origFetch(input, init);
                try {
                    if (res && res.ok && shouldTriggerImmediateRefresh(url, method)) scheduleImmediateRefresh();
                } catch (_) { /* ignore */ }
                return res;
            };
        })();

        // 工具函数：打开诊断页
        function openInspect() {
            window.open('/inspect.html','_blank');
        }

        // 数字格式化（USDT）
        function formatUSDT(val) {
            if (typeof val !== 'number' || !isFinite(val)) return '—';
            const abs = Math.abs(val);
            if (abs >= 1e9) return (val / 1e9).toFixed(2) + 'B USDT';
            if (abs >= 1e6) return (val / 1e6).toFixed(2) + 'M USDT';
            if (abs >= 1e3) return (val / 1e3).toFixed(2) + 'K USDT';
            return val.toFixed(2) + ' USDT';
        }

        // 时间格式化 HH:MM:SS
        function fmtTime(ts) {
            const d = new Date(ts);
            const pad = n => String(n).padStart(2, '0');
            return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
        }
        
        // 请求工具：支持超时与指数退避重试
        async function requestJsonWithRetry(url, options = {}, cfg = { retries: 2, timeoutMs: 5000, backoffMs: 600 }) {
            let attempt = 0;
            let lastErr;
            while (attempt <= (cfg.retries ?? 0)) {
                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), cfg.timeoutMs ?? 5000);
                try {
                    const res = await fetch(url, { ...options, signal: controller.signal, cache: 'no-store' });
                    clearTimeout(timeout);
                    if (!res.ok) throw new Error(`HTTP ${res.status}`);
                    return await res.json();
                } catch (e) {
                    clearTimeout(timeout);
                    lastErr = e;
                    // 更新内联状态为重试中
                    const st = document.getElementById('marketInlineStatus');
                    if (st) {
                        st.className = 'inline-status warn';
                        st.textContent = '连接不稳定，正在重试...';
                    }
                    if (attempt === (cfg.retries ?? 0)) break;
                    const delay = (cfg.backoffMs ?? 600) * Math.pow(2, attempt);
                    await new Promise(r => setTimeout(r, delay));
                }
                attempt++;
            }
            throw lastErr;
        }
        
        // 基于合约信息的回退渲染（当 /api/market/ticker 失败时）
        function updateDomWithMarketFallback(contract) {
            try {
                const priceEl = document.getElementById('currentPrice');
                const changeElLegacy = document.getElementById('priceChange');
                const volumeEl = document.getElementById('volume');
                const volEl = document.getElementById('volatility');
                const lowHighEl = document.getElementById('lowHigh24h');
                const fundingEl = document.getElementById('fundingRate');
                const mark = Number(contract && contract.markPrice);
                if (priceEl) {
                    if (Number.isFinite(mark)) {
                        priceEl.textContent = '$' + mark.toFixed(2);
                    } else {
                        priceEl.textContent = '--';
                    }
                }
                if (changeElLegacy) {
                    const pct24h = Number(contract && contract.priceChangePercent24h);
                    if (Number.isFinite(pct24h)) {
                        changeElLegacy.textContent = pct24h.toFixed(2) + '%';
                        changeElLegacy.style.color = pct24h >= 0 ? '#10b981' : '#ef4444';
                    } else {
                        changeElLegacy.textContent = '—';
                        changeElLegacy.style.color = '#6b7280';
                    }
                }
                if (volumeEl) {
                    const t = Number(contract && contract.turnover24h);
                    if (Number.isFinite(t)) {
                        volumeEl.textContent = formatUSDT(t);
                    } else {
                        volumeEl.textContent = '—';
                    }
                }
                if (volEl) {
                    // 无高低价信息，无法计算振幅，置为占位
                    volEl.textContent = '—';
                    volEl.classList.remove('loading-inline');
                }
                if (lowHighEl) {
                    lowHighEl.textContent = '--';
                }
                if (fundingEl) {
                    const fr = Number(contract && contract.fundingRate);
                    fundingEl.textContent = (Number.isFinite(fr)) ? (fr * 100).toFixed(4) + '%' : '--';
                }
            } catch (e) {
                console.warn('回退渲染失败:', e);
            }
        }
        
        // FGI 渲染：根据数值在半圆上定位指示点，并更新文案（含动画与分段高亮）
        function renderFGI(value, label) {
            try {
                const pointer = document.getElementById('fgiDot');
                const valEl = document.getElementById('fgiValue');
                const labEl = document.getElementById('fgiLabel');
                if (!pointer || !valEl || !labEl) return;
                if (typeof value !== 'number' || !isFinite(value)) {
                    valEl.textContent = '--';
                    labEl.textContent = '恐惧贪婪指数';
                    return;
                }
                const v = Math.max(0, Math.min(100, value));
                valEl.textContent = String(Math.round(v));
                // 阈值分类：0-20 极度恐惧，20-40 恐惧，40-60 中性，60-80 贪婪，80-100 极度贪婪（左闭右开，最后一档含 100）
                const classify = (n) => (n < 20 ? '极度恐惧' : n < 40 ? '恐惧' : n < 60 ? '中性' : n < 80 ? '贪婪' : '极度贪婪');
                // 统一以数值阈值映射为准，避免接口标签覆盖造成错判（例如 44 应显示“中性”）
                labEl.textContent = classify(v);
                // 半圆映射：0 -> π, 100 -> 0
                const angle = Math.PI * (1 - v / 100);
                const r = 90;
                const cx = 100 + r * Math.cos(angle);
                const cy = 100 - r * Math.sin(angle);
                pointer.setAttribute('cx', cx.toFixed(2));
                pointer.setAttribute('cy', cy.toFixed(2));

                // 保持所有颜色段固定显示，取消动态高亮，仅移动指示点
                // 指示点样式已通过 CSS 定义，这里不修改颜色
            } catch (e) {
                console.warn('渲染FGI失败:', e);
            }
        }
        
        // 加载 FGI 数据（使用本地超时控制，避免复用市场数据的内联状态提示）
        async function loadFGI() {
            const ctrl = new AbortController();
            const timer = setTimeout(() => ctrl.abort(), 8000);
            try {
                const res = await fetch('/api/sentiment/fgi', { signal: ctrl.signal, cache: 'no-store' });
                clearTimeout(timer);
                if (!res.ok) throw new Error('HTTP ' + res.status);
                const payload = await res.json();
                const d = payload?.data ?? payload;
                const val = typeof d?.value === 'number' ? d.value : Number(d?.value);
                const label = d?.value_classification || d?.classification || null;
                renderFGI(val, label);
            } catch (err) {
                clearTimeout(timer);
                console.warn('加载FGI失败:', err);
                renderFGI(NaN, null);
            }
        }
        
        // 加载滑点数据
        async function loadSlippageData() {
            const statusEl = document.getElementById('slippageInlineStatus');
            if (statusEl) {
                statusEl.className = 'inline-status warn';
                statusEl.textContent = '正在加载...';
            }
            
            try {
                // 获取滑点统计
                const statsRes = await fetch('/api/slippage/statistics', { cache: 'no-store' });
                if (!statsRes.ok) throw new Error('HTTP ' + statsRes.status);
                const statsData = await statsRes.json();
                const stats = statsData?.data || statsData || {};
                
                // 获取滑点阈值
                const thresholdsRes = await fetch('/api/slippage/thresholds', { cache: 'no-store' });
                if (!thresholdsRes.ok) throw new Error('HTTP ' + thresholdsRes.status);
                const thresholdsData = await thresholdsRes.json();
                const thresholds = thresholdsData?.data || thresholdsData || {};
                
                // 获取滑点分析历史（最近50条）
                const analysisRes = await fetch('/api/slippage/analysis?limit=50', { cache: 'no-store' });
                if (!analysisRes.ok) throw new Error('HTTP ' + analysisRes.status);
                const analysisData = await analysisRes.json();
                const analysisHistory = analysisData?.data || analysisData || [];
                
                // 更新显示数据
                updateSlippageDisplay(stats, thresholds, analysisHistory);
                
                if (statusEl) {
                    statusEl.className = 'inline-status ok';
                    statusEl.textContent = '';
                }
                
                // 3秒后恢复状态
                setTimeout(() => {
                    if (statusEl) {
                        statusEl.className = 'inline-status';
                        statusEl.textContent = '';
                    }
                }, 3000);
                
            } catch (err) {
                console.warn('加载滑点数据失败:', err);
                if (statusEl) {
                    statusEl.className = 'inline-status err';
                    statusEl.textContent = '加载失败';
                }
            }
        }
        
        // 更新滑点显示
        function updateSlippageDisplay(stats, thresholds, analysisHistory) {
            try {
                // 更新基本指标（统一转换为百分比小数：0.0047 表示 0.47%）
                const avgBps = (typeof stats?.avg_slippage_bps === 'number') ? stats.avg_slippage_bps
                              : (typeof stats?.average_slippage_bps === 'number') ? stats.average_slippage_bps
                              : null;
                const avgSlippageRaw = (avgBps != null && isFinite(avgBps))
                    ? (avgBps / 10000)
                    : ((typeof stats?.average_slippage === 'number') ? stats.average_slippage
                        : ((typeof stats?.avg_slippage === 'number') ? stats.avg_slippage : 0));
                
                const maxBps = (typeof stats?.max_slippage_bps === 'number') ? stats.max_slippage_bps : null;
                const maxSlippageRaw = (maxBps != null && isFinite(maxBps))
                    ? (maxBps / 10000)
                    : ((typeof stats?.max_slippage === 'number') ? stats.max_slippage : 0);
                
                // 兼容后端 new API: data.current_thresholds.ev_threshold 为小数阈值
                const evThr = (typeof thresholds?.current_thresholds?.ev_threshold === 'number')
                    ? thresholds.current_thresholds.ev_threshold
                    : (typeof thresholds?.ev_threshold === 'number') ? thresholds.ev_threshold
                    : null;

                const thBps = (typeof thresholds?.threshold_bps === 'number') ? thresholds.threshold_bps
                             : (typeof thresholds?.buy_threshold_bps === 'number') ? thresholds.buy_threshold_bps
                             : (typeof thresholds?.sell_threshold_bps === 'number') ? thresholds.sell_threshold_bps
                             : (typeof stats?.suggested_threshold_bps === 'number') ? stats.suggested_threshold_bps
                             : null;
                const thresholdRaw = (thBps != null && isFinite(thBps))
                    ? (thBps / 10000)
                    : (evThr != null && isFinite(evThr)) ? evThr
                    : ((typeof thresholds?.buy_threshold === 'number') ? thresholds.buy_threshold
                        : ((typeof thresholds?.sell_threshold === 'number') ? thresholds.sell_threshold : 0));
                
                // Fallback：若统计/阈值为 0 或缺失，则根据分析历史推导
                const toFraction = (val, isBps) => (typeof val === 'number' && isFinite(val)) ? (isBps ? val / 10000 : val) : 0;
                const getNum = (obj, keys) => {
                    for (const k of keys) {
                        const v = obj && obj[k];
                        if (typeof v === 'number' && isFinite(v)) return v;
                    }
                    return null;
                };
                const fromAnalysis = (() => {
                    if (!Array.isArray(analysisHistory) || analysisHistory.length === 0) return { avg: 0, max: 0, thr: 0 };
                    const recent = analysisHistory.slice(-20);
                    const slippages = [];
                    const thresholdsArr = [];
                    for (const item of recent) {
                        const sBps = getNum(item, ['slippage_bps', 'avg_slippage_bps']);
                        const s = toFraction(sBps != null ? sBps : (getNum(item, ['slippage', 'avg_slippage']) || 0), sBps != null);
                        slippages.push(s);
                        const tBps = getNum(item, ['threshold_bps', 'suggested_threshold_bps']);
                        const t = toFraction(tBps != null ? tBps : (getNum(item, ['threshold']) || 0), tBps != null);
                        if (t > 0) thresholdsArr.push(t);
                    }
                    const avg = slippages.length ? slippages.reduce((a,b)=>a+b,0)/slippages.length : 0;
                    const max = slippages.length ? Math.max(...slippages) : 0;
                    const thr = thresholdsArr.length ? thresholdsArr[thresholdsArr.length-1] : 0;
                    return { avg, max, thr };
                })();
                
                const avgToShow = (isFinite(avgSlippageRaw) && avgSlippageRaw > 0) ? avgSlippageRaw : fromAnalysis.avg;
                const maxToShow = (isFinite(maxSlippageRaw) && maxSlippageRaw > 0) ? maxSlippageRaw : fromAnalysis.max;
                const thrToShow = (isFinite(thresholdRaw) && thresholdRaw > 0) ? thresholdRaw : fromAnalysis.thr;
                const thrDisplay = (isFinite(thresholdRaw) && thresholdRaw > 0) || (isFinite(fromAnalysis.thr) && fromAnalysis.thr > 0)
                    ? formatPercentage(thrToShow)
                    : '--';
                
                document.getElementById('avgSlippage').textContent = isFinite(avgToShow) ? formatPercentage(avgToShow) : '--';
                document.getElementById('maxSlippage').textContent = isFinite(maxToShow) ? formatPercentage(maxToShow) : '--';
                document.getElementById('slippageThreshold').textContent = thrDisplay;
                
                // 计算滑点趋势
                const trend = calculateSlippageTrend(analysisHistory);
                document.getElementById('slippageTrend').textContent = trend.text;
                document.getElementById('slippageTrend').style.color = trend.color;
                
                // 更新阈值调整状态
                const autoAdjustment = thresholds?.auto_adjustment !== false;
                document.getElementById('autoAdjustmentStatus').textContent = autoAdjustment ? '启用' : '禁用';
                document.getElementById('autoAdjustmentStatus').style.color = autoAdjustment ? '#27ae60' : '#e74c3c';
                
                // 最后调整时间
                const lastAdjustment = thresholds?.last_adjustment_time || thresholds?.last_updated || stats?.last_updated;
                document.getElementById('lastAdjustmentTime').textContent = lastAdjustment ? 
                    new Date(lastAdjustment).toLocaleString('zh-CN') : '--';
                
                // 绘制图表
                drawSlippageChart(analysisHistory);
                
            } catch (err) {
                console.warn('更新滑点显示失败:', err);
            }
        }
        
        // 计算滑点趋势
        function calculateSlippageTrend(analysisHistory) {
            if (!Array.isArray(analysisHistory) || analysisHistory.length < 2) {
                return { text: '数据不足', color: '#999' };
            }
            
            try {
                // 统一取值为“小数形式的百分比”（如 0.0047 表示 0.47%）
                const toFraction = (item) => {
                    const bps = (typeof item?.slippage_bps === 'number') ? item.slippage_bps
                              : (typeof item?.avg_slippage_bps === 'number') ? item.avg_slippage_bps
                              : null;
                    if (bps != null && isFinite(bps)) return bps / 10000; // bps -> fraction
                    const frac = (typeof item?.slippage === 'number') ? item.slippage
                               : (typeof item?.avg_slippage === 'number') ? item.avg_slippage
                               : 0;
                    return (isFinite(frac) ? frac : 0);
                };
                
                const fracSeries = analysisHistory.map(toFraction);
                const recent = fracSeries.slice(-10); // 最近10条
                const older = fracSeries.slice(-20, -10); // 前10条
                
                const avg = (arr) => arr.reduce((s, v) => s + (isFinite(v) ? v : 0), 0) / (arr.length || 1);
                const recentAvg = avg(recent);
                const olderAvg = avg(older);
                
                const change = recentAvg - olderAvg;
                const changePercent = olderAvg > 0 ? (change / olderAvg) * 100 : 0;
                
                if (Math.abs(changePercent) < 5) {
                    return { text: '稳定', color: '#f39c12' };
                } else if (changePercent > 5) {
                    return { text: `上升 ${changePercent.toFixed(1)}%`, color: '#e74c3c' };
                } else {
                    return { text: `下降 ${Math.abs(changePercent).toFixed(1)}%`, color: '#27ae60' };
                }
            } catch (err) {
                return { text: '计算失败', color: '#999' };
            }
        }
        
        // 绘制滑点图表
        function drawSlippageChart(analysisHistory) {
            try {
                const canvas = document.getElementById('slippageChart');
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                // 清空画布
                ctx.clearRect(0, 0, width, height);
                
                if (!Array.isArray(analysisHistory) || analysisHistory.length === 0) {
                    ctx.fillStyle = '#999';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('暂无数据', width / 2, height / 2);
                    return;
                }
                
                // 统一将数据转换为“小数形式的百分比”（如 0.0047 表示 0.47%）
                const toFraction = (val, isBps) => {
                    if (typeof val !== 'number' || !isFinite(val)) return 0;
                    return isBps ? val / 10000 : val;
                };
                const getNum = (obj, keys) => {
                    for (const k of keys) {
                        const v = obj && obj[k];
                        if (typeof v === 'number' && isFinite(v)) return v;
                    }
                    return null;
                };
                
                const data = analysisHistory.slice(-30).map(item => {
                    const t = new Date(item.timestamp || item.created_at || Date.now());
                    const slippageBps = getNum(item, ['slippage_bps', 'avg_slippage_bps']);
                    const slippageFrac = toFraction(slippageBps != null ? slippageBps : getNum(item, ['slippage', 'avg_slippage']) || 0, slippageBps != null);
                    const thresholdBps = getNum(item, ['threshold_bps', 'suggested_threshold_bps']);
                    const thresholdFrac = toFraction(thresholdBps != null ? thresholdBps : getNum(item, ['threshold']) || 0, thresholdBps != null);
                    return { time: t, slippage: slippageFrac, threshold: thresholdFrac };
                });
                
                // 计算边界
                const maxSlippage = Math.max(...data.map(d => Math.max(d.slippage, d.threshold)));
                const minSlippage = Math.min(...data.map(d => Math.min(d.slippage, d.threshold)));
                const padding = 0.001; // 0.1% 边距（以 fraction 计）
                let maxValue = (isFinite(maxSlippage) ? maxSlippage : 0) + padding;
                let minValue = Math.max(0, (isFinite(minSlippage) ? minSlippage : 0) - padding);
                if (maxValue - minValue < 1e-6) { // 防止除零
                    maxValue += 0.001;
                    minValue = Math.max(0, minValue - 0.001);
                }
                
                // 绘制网格
                ctx.strokeStyle = '#e0e0e0';
                ctx.lineWidth = 1;
                
                // 水平网格线
                for (let i = 0; i <= 4; i++) {
                    const y = (height - 40) * (i / 4) + 20;
                    ctx.beginPath();
                    ctx.moveTo(40, y);
                    ctx.lineTo(width - 20, y);
                    ctx.stroke();
                    
                    // Y轴标签
                    const value = maxValue - (maxValue - minValue) * (i / 4);
                    ctx.fillStyle = '#666';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'right';
                    ctx.fillText(formatPercentage(value), 35, y + 3);
                }
                
                // 绘制滑点线
                ctx.strokeStyle = '#3498db';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                data.forEach((point, index) => {
                    const x = 40 + (width - 60) * (index / Math.max(1, (data.length - 1)));
                    const y = height - 20 - (point.slippage - minValue) / (maxValue - minValue) * (height - 40);
                    
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();
                
                // 绘制阈值线
                if (data.some(d => d.threshold > 0)) {
                    ctx.strokeStyle = '#e74c3c';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                    
                    const avgThreshold = data.reduce((sum, d) => sum + d.threshold, 0) / data.length;
                    const y = height - 20 - (avgThreshold - minValue) / (maxValue - minValue) * (height - 40);
                    
                    ctx.beginPath();
                    ctx.moveTo(40, y);
                    ctx.lineTo(width - 20, y);
                    ctx.stroke();
                    
                    ctx.setLineDash([]);
                    
                    // 阈值标签
                    ctx.fillStyle = '#e74c3c';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText('阈值', width - 50, y - 2);
                }
                
            } catch (err) {
                console.warn('绘制滑点图表失败:', err);
            }
        }
        
        // 格式化百分比
        function formatPercentage(value) {
            if (typeof value !== 'number' || !isFinite(value)) return '--';
            return (value * 100).toFixed(3) + '%';
        }
        

        // 页面加载时初始化
        window.onload = function() {
            // 加载各类数据
            loadMarketData();
            loadSystemStatus();
            loadLatestSignal();
            loadPerformanceData();
            loadTradeRecommendation();
            loadRecommendationHistory();
            loadFGI();
            loadSlippageData();
            renderTradingCosts();
            
            // 新增：首屏兜底渲染“策略单进度”，避免用户刷新后短时间内看不到
            setTimeout(async () => {
                try {
                    const listEl = document.getElementById('perfOrderProgressList');
                    if (listEl && !listEl.innerHTML.trim()) {
                        const cfg = await ensureAppConfig();
                        const fallbackAnalysis = { signal: { type: 'HOLD', strength: 0, confidence: 0.5 } };
                        renderOrderProgressFromAnalysis(fallbackAnalysis, cfg);
                    }
                } catch (_) {}
            }, 200);
            
            // 启动自动更新
            updateInterval = setInterval(() => {
                loadLatestSignal();
                loadMarketData();
                updateUptime();
                loadTradeRecommendation();
                loadRecommendationHistory(true);
                loadFGI();
                // 滑点刷新改为独立高频定时器
            }, 30000); // 30秒更新一次

            // 独立：滑点每10秒刷新一次
            if (window.__slippageTimer) clearInterval(window.__slippageTimer);
            window.__slippageTimer = setInterval(() => {
                try { loadSlippageData(); } catch (e) { /* ignore */ }
            }, 10000);

            // 仅刷新滑点按钮
            const rsBtn = document.getElementById('refreshSlippageBtn');
            if (rsBtn) rsBtn.addEventListener('click', () => {
                try { loadSlippageData(); } catch (e) { /* ignore */ }
            });
        };
        
        // 预取一次配置，供进度阈值计算
        ensureAppConfig().catch(()=>{});
        
        // 拉取系统配置（阈值/分析周期）
        async function ensureAppConfig() {
            if (window.__appConfig && window.__appConfig.strategy) return window.__appConfig;
            try {
                const res = await fetch('/api/config');
                const payload = await res.json();
                const cfg = payload?.data || payload || {};
                window.__appConfig = cfg;
                return cfg;
            } catch (e) {
                console.warn('拉取配置失败, 使用默认阈值', e);
                const fallback = { strategy: { signalThreshold: 0.5, analysisInterval: 30000, signalCooldownMs: 1800000 } };
                window.__appConfig = fallback;
                return fallback;
            }
        }
        
        function renderTradingCosts() {
            try {
                ensureAppConfig().then(cfg => {
                    const el = document.getElementById('costInfo');
                    if (!el) return;
                    const c = Number(cfg?.commission);
                    const s = Number(cfg?.slippage);
                    const fmt = v => isFinite(v) ? (((v*100) < 0.1 ? (v*100).toFixed(3) : (v*100).toFixed(2)) + '%') : '--';
                    // 不再显示交易成本信息
                    el.textContent = '';
                }).catch(()=>{});
            } catch (_) {}
        }
        
        // 更新 Kronos 参与状态（读取配置与最新分析，计算方向、置信度与融合占比）
        function updateKronosStatus(analysis) {
            try {
                const container = document.getElementById('kronosStatus');
                // 异步读取配置（不阻塞主流程）
                ensureAppConfig().then(cfg => {
                    const kronosCfg = cfg?.strategy?.kronos || {};
                    const enabled = !!kronosCfg.enabled;

                    // 更新状态栏“Kronos模型”的小圆点颜色
                    try {
                        const items = document.querySelectorAll('.status-bar .status-item');
                        items.forEach(el => {
                            const span = el.querySelector('span');
                            if (span && span.textContent && span.textContent.includes('Kronos')) {
                                const dot = el.querySelector('.status-dot');
                                if (dot) dot.style.background = enabled ? '#27ae60' : '#9ca3af';
                            }
                        });
                    } catch (_) {}

                    if (!container) return;
                    if (!enabled) {
                        container.innerHTML = '<span style="color:#6b7280">Kronos 已关闭</span>';
                        return;
                    }

                    // 兼容多种响应结构：优先 signal.metadata.kronos，其次 analysis.metadata.kronos
                    const sig = analysis?.signal || analysis || {};
                    const metaK = sig?.metadata?.kronos || analysis?.metadata?.kronos || null;

                    if (!metaK) {
                        container.innerHTML = '<span style="color:#9ca3af">Kronos 无最近结果</span>';
                        return;
                    }

                    const clamp01 = v => Math.max(0, Math.min(1, Number(v) || 0));
                    const longS = clamp01(metaK.score_long);
                    const shortS = clamp01(metaK.score_short);
                    const conf = clamp01(metaK.confidence ?? 0.5);
                    const directional = longS - shortS; // [-1, 1]
                    const dirText = directional > 0.05 ? '多' : (directional < -0.05 ? '空' : '中性');
                    const dirPct = Math.abs(directional) * 100;

                    // 显示融合权重：优先取配置中的 alpha/alphaMin/alphaMax，其次用置信度作为动态α
                    let alpha = typeof kronosCfg.alpha === 'number' ? clamp01(kronosCfg.alpha) : conf;
                    const minA = typeof kronosCfg.alphaMin === 'number' ? clamp01(kronosCfg.alphaMin) : 0.3;
                    const maxA = typeof kronosCfg.alphaMax === 'number' ? clamp01(kronosCfg.alphaMax) : 0.8;
                    alpha = Math.max(minA, Math.min(maxA, alpha));

                    container.innerHTML = `
                        <div style="font-size:12px;color:#374151;display:flex;align-items:center;gap:8px;flex-wrap:wrap">
                            <span>模型：已启用</span>
                            <span>倾向：${dirText} ${dirPct.toFixed(1)}%</span>
                            <span>置信度：${(conf * 100).toFixed(1)}%</span>
                            <span>融合权重α：${(alpha * 100).toFixed(0)}%</span>
                        </div>`;
                }).catch(_ => {
                    if (container) container.innerHTML = '<span style="color:#9ca3af">Kronos 状态不可用</span>';
                });
            } catch (_) {}
        }
        
        // 根据最新分析渲染“策略单进度”
        function renderOrderProgressFromAnalysis(analysis, cfg) {
            try {
                const listEl = document.getElementById('perfOrderProgressList');
                if (!listEl) return;
                const s = analysis?.signal || {};
                const rec = analysis?.recommendation || {};
                // 强度归一化
                let combined = 0;
                if (typeof s.strength === 'number') {
                    combined = Math.max(0, Math.min(1, s.strength));
                } else if (s.strength && typeof s.strength.combined === 'number') {
                    combined = s.strength.combined > 1 ? s.strength.combined / 100 : s.strength.combined;
                    combined = Math.max(0, Math.min(1, combined));
                }
                // 置信度
                let confidence = null;
                if (typeof s.confidence === 'number') confidence = s.confidence;
                else if (s.strength && typeof s.strength.confidence === 'number') confidence = s.strength.confidence;
                else if (typeof rec.confidence === 'number') confidence = rec.confidence;
                // 阈值归一化：后端可能返回 0-1 或 0-100；同时避免 0 导致进度被清零
                let thresholdRaw = cfg?.strategy?.signalThreshold;
                let threshold = Number(thresholdRaw);
                if (!isFinite(threshold)) threshold = 0.5; // 默认 50%
                if (threshold > 1) threshold = threshold / 100; // 百分比转小数
                threshold = Math.max(0.05, Math.min(1, threshold)); // 至少 5%，避免 0%
                // 把显示从“相对阈值”改为“绝对强度”，避免强度65%但显示100%的误导
                const strengthPct = Math.round(Math.max(0, Math.min(1, combined)) * 100);
                const intervalMs = Number(cfg?.strategy?.analysisInterval ?? 30000);
                // ETA 基于阈值（如无阈值则显示 '—'）
                let etaText = '--';
                if (threshold != null && threshold > 0) {
                    if (combined >= threshold) {
                        etaText = '已达阈值，随时可能出单';
                    } else {
                        const speed = Math.max(0.01, (confidence ?? 0.6) * 0.08);
                        const remaining = Math.max(0, threshold - combined);
                        const cycles = Math.ceil(remaining / speed);
                        const etaMs = cycles * intervalMs;
                        const m = Math.floor(etaMs / 60000);
                        const sLeft = Math.round((etaMs % 60000) / 1000);
                        etaText = (m > 0 ? (m + '分') : '') + sLeft + '秒';
                    }
                } else {
                    etaText = '—';
                }
                const t = String(s.type || s.signal || rec.action || '').toUpperCase();
                const side = (t.includes('SELL') || t.includes('SHORT')) ? '做空' : (t.includes('BUY') || t.includes('LONG')) ? '做多' : '观望';
                const title = `当前信号 ${side}`;
                const detail = `强度 ${(combined*100).toFixed(1)}% · 置信度 ${confidence!=null? (confidence*100).toFixed(0)+'%':'--'} · 阈值 ${threshold!=null? (threshold*100).toFixed(0)+'%':'—'}`;
                const barHtml = `
                    <div id="orderProgressItem" class="order-progress-item" style="background:#f8fafc;border:1px solid #e5e7eb;border-radius:8px;padding:8px 10px">
                        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
                            <div style="font-weight:600;color:#111827">${title}</div>
                            <div id="orderProgressEta" style="font-size:12px;color:#6b7280">预计达标: ${etaText}</div>
                        </div>
                        <div class="progress" style="background:#e5e7eb;border-radius:6px;height:10px;position:relative;overflow:hidden">
                            <div id="orderProgressFill" class="progress-fill" style="height:100%;width:${strengthPct}%;background:linear-gradient(90deg,#34d399,#10b981);transition:width .4s ease"></div>
                            ${threshold!=null? `<div style="position:absolute;left:${Math.min(100, threshold*100)}%;top:0;bottom:0;width:2px;background:#fbbf24"></div>` : ''}
                        </div>
                        <div style="display:flex;justify-content:space-between;font-size:12px;color:#6b7280;margin-top:4px">
                            <span>${detail}</span>
                            <span id="orderProgressPct">${strengthPct}%</span>
                        </div>
                    </div>`;
                // 避免刷新时清空整个容器：先检查是否已存在 analysisProgressItem
                let analysisItem = document.getElementById('analysisProgressItem');
                if (!analysisItem) {
                    // 仅设置策略单进度 HTML，并创建实时分析进度容器
                    listEl.innerHTML = barHtml + '<div id="analysisProgressItem" style="margin-top:8px"></div>';
                } else {
                    // 已存在实时分析进度容器，仅更新策略单进度部分
                    const orderItem = document.getElementById('orderProgressItem');
                    if (orderItem) {
                        orderItem.outerHTML = barHtml;
                    } else {
                        // 如果没找到，则插入到 analysisProgressItem 前面
                        analysisItem.insertAdjacentHTML('beforebegin', barHtml);
                    }
                }
                // 新增：策略单生成进度（非冷却期）的每秒动态刷新
                try {
                    if (window.__orderProgressTimer) { clearInterval(window.__orderProgressTimer); }
                    const etaEl = document.getElementById('orderProgressEta');
                    const fillEl = document.getElementById('orderProgressFill');
                    const pctEl  = document.getElementById('orderProgressPct');
                    const intervalMsLocal = Number(intervalMs);
                    const thresholdLocal = (typeof threshold === 'number' && threshold > 0) ? threshold : null;
                    const confidenceLocal = (confidence != null ? Number(confidence) : 0.6);
                    const baseCombined = Number(combined);
                    const t0 = Date.now();
                    const speed = Math.max(0.01, confidenceLocal * 0.08); // 每个分析周期的期望提升量
                    function updateOrderProgress(){
                        const elapsed = Date.now() - t0;
                        const combinedPred = Math.min(1, baseCombined + (elapsed / intervalMsLocal) * speed);
                        const widthPct = Math.round(Math.max(0, Math.min(1, combinedPred)) * 100);
                        if (fillEl) fillEl.style.width = widthPct + '%';
                        if (pctEl) pctEl.textContent = widthPct + '%';
                        if (etaEl) {
                            if (thresholdLocal == null) {
                                etaEl.textContent = '预计达标: —';
                            } else if (combinedPred >= thresholdLocal) {
                                etaEl.textContent = '已达阈值，随时可能出单';
                            } else {
                                const remaining = Math.max(0, thresholdLocal - combinedPred);
                                const cycles = Math.ceil(remaining / speed);
                                const etaMs2 = cycles * intervalMsLocal;
                                const m = Math.floor(etaMs2 / 60000);
                                const sLeft = Math.round((etaMs2 % 60000) / 1000);
                                etaEl.textContent = '预计达标: ' + (m > 0 ? (m + '分') : '') + sLeft + '秒';
                            }
                        }
                        if (thresholdLocal != null && combinedPred >= thresholdLocal) {
                            clearInterval(window.__orderProgressTimer);
                        }
                    }
                    window.__orderProgressTimer = setInterval(updateOrderProgress, 1000);
                    updateOrderProgress();
                } catch(__e) { /* 忽略单次刷新失败 */ }
            } catch (e) { console.warn('renderOrderProgressFromAnalysis error:', e); }
        }
        
        // 阶段名称映射（如需调整可修改此处中文文案）
        const stageLabels = { 1:'数据拉取', 2:'信号检测', 3:'回测', 4:'风控', 5:'下发推荐' };

        // 新增：渲染“实时分析进度”（Socket 推送） - 增强版
        function renderRealtimeAnalysisProgress(progress){
            try {
                const listEl = document.getElementById('perfOrderProgressList');
                if (!listEl) return;
                let holder = document.getElementById('analysisProgressItem');
                if (!holder) {
                    holder = document.createElement('div');
                    holder.id = 'analysisProgressItem';
                    holder.style.marginTop = '8px';
                    listEl.prepend(holder);
                }

                const isConnected = !!(window.__analysisSocket && window.__analysisSocket.connected);

                // 无进度：显示占位 + 连接状态
                if (!progress) {
                    const connectionStatus = isConnected ? '已连接' : '断线';
                    const statusColor = isConnected ? '#22c55e' : '#ef4444';
                    holder.innerHTML = `
                        <div class="order-progress-item" style="background:#fafbfc;border:1px solid #e5e7eb;border-radius:12px;padding:12px 14px;text-align:center">
                            <div style="color:#64748b;font-size:14px;margin-bottom:8px">暂无分析任务</div>
                            <div style="display:flex;align-items:center;justify-content:center;gap:6px">
                                <span style="display:inline-block;width:6px;height:6px;border-radius:50%;background:${statusColor}"></span>
                                <span style="font-size:12px;color:#64748b">实时连接: ${connectionStatus}</span>
                                ${!isConnected ? '<a href="#" onclick="window.__analysisSocket?.connect?.();return false;" style="color:#3b82f6;margin-left:6px">重连</a>' : ''}
                            </div>
                        </div>`;
                    return;
                }

                const p = typeof progress.percent === 'number' ? Math.max(0, Math.min(1, progress.percent)) : 0;
                const pct = Math.round(p * 100);
                const VISUAL_TOTAL = 5; // 固定为5段
                const rawStep = Number.isFinite(progress.step) ? progress.step : 0;
                const step = Math.max(0, Math.min(VISUAL_TOTAL, rawStep));
                const total = VISUAL_TOTAL;
                const label = stageLabels[step] || (progress && progress.label ? String(progress.label) : '等待下一次分析');
                const startedAt = Number.isFinite(progress.startedAt) ? progress.startedAt : null;
                const updatedAt = Number.isFinite(progress.updatedAt) ? progress.updatedAt : null;
                const timeUsed = startedAt ? (()=>{ const ms=Math.max(0, Date.now()-startedAt); const m=Math.floor(ms/60000); const s=Math.round((ms%60000)/1000); return `${m>0? m+'分':''}${s}秒`; })() : '--';
                const lastUpd = updatedAt ? (()=>{ const diff=Math.max(0, Date.now()-updatedAt); const s=Math.floor(diff/1000); if (s<60) return `${s}s前`; const m=Math.floor(s/60); if (m<60) return `${m}分钟前`; const h=Math.floor(m/60); return `${h}小时前`; })() : '--';
                const etaText = (()=>{ if(!startedAt || p<=0 || p>=1) return '—'; const elapsed=Date.now()-startedAt; const remain=Math.max(0, Math.round(elapsed*(1/p-1))); const m=Math.floor(remain/60000); const s=Math.round((remain%60000)/1000); return `${m>0? m+'分':''}${s}秒后`; })();

                const statusText = p>=1 ? '分析完成' : `阶段 ${label} (${Math.min(step,5)}/5)`;
                const fillStyle = p>=1 ? 'linear-gradient(90deg,#10b981,#059669)' : (pct>=90 ? 'linear-gradient(90deg,#34d399,#10b981)' : 'linear-gradient(90deg,#a78bfa,#7c3aed)');

                // 阶段刻度 + 顶部中文标签（均匀分布：i/(total-1)；首尾避免贴边）
                const ticks = (total && total>1) ? Array.from({length: total}, (_, i)=>{
                    const stageNum = i+1;
                    const stageName = stageLabels[stageNum] || `阶段${stageNum}`;
                    const isActive = step >= stageNum;
                    const isFirst = stageNum === 1;
                    const isLast = stageNum === total;
                    const left = ((i/(total-1))*100).toFixed(2);
                    // 首尾标签位移策略：
                    // - 第1个：translateX(0) + 竖线贴左
                    // - 最后1个：translateX(-100%) + 竖线贴右（保证边界内可见）
                    const labelTransform = isLast ? 'translateX(-100%)' : (isFirst ? 'translateX(0)' : 'translateX(-50%)');
                    const lineMargin = isLast ? 'margin-left:auto;margin-right:0' : (isFirst ? 'margin-left:0;margin-right:auto' : 'margin:0 auto');
                    return `
                        <div class="stage-tick" style="position:absolute;left:${left}%;top:-22px;transform:${labelTransform};cursor:help" title="${stageName}">
                            <div style="font-size:10px;color:${isActive?'#059669':'#9ca3af'};font-weight:600;margin-bottom:2px;white-space:nowrap;">${stageName}</div>
                            <div style="width:1px;height:18px;background:${isActive?'#10b981':'#d1d5db'};${lineMargin};display:${isFirst?'none':'block'}"></div>
                        </div>`;
                }).join('') : '';

                // 完成勾号动画
                const completionIcon = p>=1 ? `
                    <div style="position:absolute;left:calc(${pct}% - 9px);top:-2px;width:18px;height:18px;border-radius:50%;background:#10b981;display:flex;align-items:center;justify-content:center;animation:checkmark .6s ease-in-out">
                        <svg width="10" height="8" viewBox="0 0 10 8" fill="none">
                            <path d="M1 4L4 7L9 1" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    </div>
                    <style>
                        @keyframes checkmark { 0%{ transform:scale(0) rotate(-180deg); opacity:0 } 50%{ transform:scale(1.2) rotate(-90deg); opacity:1 } 100%{ transform:scale(1) rotate(0); opacity:1 } }
                    </style>
                ` : `<div style="position:absolute;left:calc(${pct}%);top:50%;transform:translate(-50%,-50%);width:18px;height:18px;border-radius:50%;background:#fff;border:2px solid ${p>=1?'#10b981':(pct>=90?'#34d399':'#a78bfa')};box-shadow:0 1px 2px rgba(0,0,0,.12)"></div>`;

                holder.innerHTML = `
                    <div class="order-progress-item" style="background:#f9fbff;border:1px solid #e6eaf0;border-radius:12px;padding:12px 14px;box-shadow:0 1px 2px rgba(0,0,0,.04), 0 4px 10px rgba(17,24,39,.06);position:relative">
                        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
                            <div style="font-weight:700;color:#0f172a;letter-spacing:.2px">策略单进展</div>
                            <div style="display:flex;gap:8px;align-items:center">
                                <span style="display:inline-block;width:8px;height:8px;border-radius:50%;background:${isConnected?'#22c55e':'#ef4444'}"></span>
                                <div style="font-size:12px;color:#64748b">${statusText} · 预计${etaText}完成</div>
                            </div>
                        </div>
                        <div class="progress" style="background:#e9edf3;border-radius:8px;height:14px;position:relative;overflow:visible;margin:24px 0 8px 0">
                            ${ticks}
                            <div style="background:#e9edf3;border-radius:8px;height:14px;position:relative;overflow:hidden">
                                <div class="progress-fill" style="height:100%;width:${pct}%;background:${fillStyle};transition:width .45s cubic-bezier(.4,0,.2,1);${p>=1 ? 'border-radius:8px' : 'border-radius:0 8px 8px 0'}"></div>
                                <div style="position:absolute;right:-2px;top:-18px;font-size:10px;color:#6b7280;">出单</div>
                                <div style="position:absolute;left:100%;top:0;bottom:0;width:2px;background:#d7dce3"></div>
                            </div>
                            ${completionIcon}
                        </div>
                        <div style="display:flex;justify-content:space-between;font-size:12px;color:#6b7280;margin-top:8px">
                            <span>已用 ${timeUsed} · 上次更新 ${lastUpd} · <span style="color:${isConnected?'#22c55e':'#ef4444'}">${isConnected?'已连接':'断线'}</span>${!isConnected ? ' <a href="#" onclick="window.__analysisSocket?.connect?.();return false;" style="color:#3b82f6">重连</a>' : ''}</span>
                            <span style="font-variant-numeric:tabular-nums">${pct}% · 阶段 ${Math.min(step,5)}/5</span>
                        </div>
                    </div>`;

                if (p >= 1 && !window.__completionAnimationTriggered) {
                    window.__completionAnimationTriggered = true;
                    setTimeout(() => {
                        const progressEl = holder.querySelector('.progress');
                        if (progressEl) {
                            progressEl.style.opacity = '0.85';
                            progressEl.style.transition = 'opacity 1s ease-out';
                        }
                        setTimeout(() => { window.__completionAnimationTriggered = false; }, 10000);
                    }, 3000);
                }
            } catch (e) {
                console.warn('renderRealtimeAnalysisProgress error:', e);
            }
        }

        // 新增：Socket.IO 推送替代轮询（含断线重连提示）
        (function initAnalysisProgressSocket(){
            try {
                function ensureRenderPlaceholder(){ try { renderRealtimeAnalysisProgress(null); } catch {} }
                ensureRenderPlaceholder();
                if (!window.io) {
                    const s = document.createElement('script');
                    s.src = '/socket.io/socket.io.js';
                    s.onload = () => { try { initSocketLogic(); } catch (e) { console.warn('initSocketLogic error:', e); } };
                    s.onerror = () => { console.warn('加载 socket.io 客户端失败'); };
                    document.head.appendChild(s);
                } else {
                    initSocketLogic();
                }
                function initSocketLogic(){
                    try {
                        const socket = window.__analysisSocket || io();
                        window.__analysisSocket = socket;
                        socket.on('connect', () => { try { socket.emit('subscribe-updates'); } catch {} try { renderRealtimeAnalysisProgress(null); } catch {} });
                        socket.on('disconnect', () => { try { renderRealtimeAnalysisProgress(null); } catch {} });
                        socket.on('reconnect_attempt', () => { try { renderRealtimeAnalysisProgress(null); } catch {} });
                        socket.on('reconnect', () => { try { renderRealtimeAnalysisProgress(null); } catch {} });
                        socket.on('connect_error', () => { try { renderRealtimeAnalysisProgress(null); } catch {} });
                        socket.on('analysis-progress', (payload) => { renderRealtimeAnalysisProgress(payload); });
                    } catch (e) { console.warn('socket logic error:', e); }
                }
            } catch (e) { console.warn('initAnalysisProgressSocket error:', e); }
        })();
        
        // 加载系统状态
        async function loadSystemStatus() {
            try {
                const response = await fetch('/api/strategy/status');
                const data = await response.json();
                
                if (data.success) {
                    const el = document.getElementById('systemStatus');
                    if (el) {
                        el.textContent = data.data.isRunning ? '运行中' : '已停止';
                    }
                }
            } catch (error) {
                console.error('加载系统状态失败:', error);
            }
        }
        
        // 加载最新信号
        async function loadLatestSignal() {
            try {
                const response = await fetch('/api/strategy/analysis');
                const data = await response.json();
                
                if (data.success && data.data) {
                    const s = data.data.signal || {};
                    const type = s.type || s.signal || (data.recommendation && data.recommendation.action) || '—';
                    
                    // 兼容多种强度结构：数值(0-1)或对象{ combined:0-100 }
                    let strengthVal = 0;
                    if (typeof s.strength === 'number') {
                        strengthVal = s.strength;
                    } else if (s.strength && typeof s.strength.combined === 'number') {
                        strengthVal = s.strength.combined;
                    }
                    if (strengthVal > 1) strengthVal = strengthVal / 100; // 归一化到[0,1]
                    
                    // 兼容多来源的置信度
                    let confidence = null;
                    if (typeof s.confidence === 'number') {
                        confidence = s.confidence;
                    } else if (s.strength && typeof s.strength.confidence === 'number') {
                        confidence = s.strength.confidence;
                    } else if (data.recommendation && typeof data.recommendation.confidence === 'number') {
                        confidence = data.recommendation.confidence;
                    }
                    
                    // 价格：优先使用 signal.price -> targetPrice -> market.price -> 支撑位
                    let price = null;
                    if (typeof s.price === 'number') {
                        price = s.price;
                    } else if (typeof s.targetPrice === 'number') {
                        price = s.targetPrice;
                    } else if (data.data.market && typeof data.data.market.price === 'number') {
                        price = data.data.market.price;
                    } else if (data.data.marketAnalysis && typeof data.data.marketAnalysis.support === 'number') {
                        price = data.data.marketAnalysis.support;
                    }
                    
                    const signalDiv = document.getElementById('currentSignal');
                    const strengthPct = isFinite(strengthVal) ? (strengthVal * 100) : 0;
                    const priceText = typeof price === 'number' ? price.toFixed(2) : '--';
                    const confText = typeof confidence === 'number' ? (confidence * 100).toFixed(1) + '%' : '--';
                    
                    if (signalDiv) {
                        signalDiv.innerHTML = `
                            <div class="signal-strength">
                                <strong>${type}</strong>
                                <div class="strength-bar">
                                    <div class="strength-fill" style="width: ${Math.max(0, Math.min(100, strengthPct))}%"></div>
                                </div>
                                <span>${isFinite(strengthPct) ? strengthPct.toFixed(1) : '--'}%</span>
                            </div>
                            <p>价格: $${priceText} | 置信度: ${confText}</p>
                            <div id="kronosStatus" class="kronos-status" style="margin-top: 8px;"></div>
                        `;
                    }
                    
                    const _strengthEl = document.getElementById('signalStrength');
                    if (_strengthEl) _strengthEl.textContent = isFinite(strengthPct) ? strengthPct.toFixed(1) + '%' : '--';
                    const _confEl = document.getElementById('confidence');
                    if (_confEl) _confEl.textContent = confText;
                    
                    // 更新 Kronos 参与状态
                    updateKronosStatus(data.data);

                    // 更新“策略性能”中的 Kronos 分数模块（非阻塞）
                    try { updateKronosPerfCard(data.data); } catch (_) {}
                        
                    // 更新风险管理数据（带健壮性检查）
                    if (data.data.riskManagement) {
                        const risk = data.data.riskManagement;
                        const _riskScoreEl = document.getElementById('riskScore');
                        if (typeof risk.riskScore === 'number' && _riskScoreEl) _riskScoreEl.textContent = risk.riskScore.toFixed(1);
                        const _posEl = document.getElementById('positionSize');
                        if (_posEl) _posEl.textContent = confText;
                        const _stopLossEl = document.getElementById('stopLoss');
                        if (typeof risk.stopLoss === 'number' && _stopLossEl) _stopLossEl.textContent = '$' + risk.stopLoss.toFixed(2);
                        const _takeProfitEl = document.getElementById('takeProfit');
                        if (typeof risk.takeProfit === 'number' && _takeProfitEl) _takeProfitEl.textContent = '$' + risk.takeProfit.toFixed(2);
                    }
                    
                    
                    // 渲染“策略单进度”（使用最新分析结果 + 配置阈值）
                    try {
                        const cfg = await ensureAppConfig();
                        renderOrderProgressFromAnalysis(data.data, cfg);
                    } catch (e) {
                        console.warn('渲染策略单进度失败:', e);
                    }
                } else {
                    const el = document.getElementById('currentSignal');
                    if (el) el.innerHTML = 
                        '<div class="loading">暂无信号数据</div>';
                    // 新增：在缺少分析数据时也渲染“策略单进度”的回退UI
                    try {
                        const cfg = await ensureAppConfig();
                        const fallbackAnalysis = { signal: { type: 'HOLD', strength: 0, confidence: 0.5 } };
                        renderOrderProgressFromAnalysis(fallbackAnalysis, cfg);
                        try { updateKronosPerfCard(fallbackAnalysis); } catch (_) {}
                    } catch (_) {}
                }
            } catch (error) {
                console.error('加载信号失败:', error);
                const el = document.getElementById('currentSignal');
                if (el) el.innerHTML = 
                    '<div class="error">信号加载失败</div>';
                // 兜底：迷你信号显示为观望 0%
                try { updateInlineSignalMini('HOLD', 0); } catch (_) {}
                // 新增：请求失败时也渲染回退进度，让用户能看到“推荐单生成进度条”
                try {
                    const cfg = await ensureAppConfig();
                    const fallbackAnalysis = { signal: { type: 'HOLD', strength: 0, confidence: 0.5 } };
                    renderOrderProgressFromAnalysis(fallbackAnalysis, cfg);
                    try { updateKronosPerfCard(fallbackAnalysis); } catch (_) {}
                } catch (_) {}
            }
        }
        
        // 在“策略性能”卡片中动态展示 Kronos 模型分数（非阻塞，带兜底）
        function updateKronosPerfCard(analysis) {
            try {
                ensureAppConfig().then(cfg => {
                    const kronosCfg = cfg?.strategy?.kronos || {};
                    const enabled = !!kronosCfg.enabled;

                    const listEl = document.getElementById('perfOrderProgressList');
                    if (!listEl || !listEl.parentElement) return;

                    let perfK = document.getElementById('kronosPerfContainer');
                    if (!perfK) {
                        perfK = document.createElement('div');
                        perfK.id = 'kronosPerfContainer';
                        perfK.style.marginTop = '8px';
                        perfK.style.border = '1px solid #e5e7eb';
                        perfK.style.borderRadius = '8px';
                        perfK.style.padding = '8px 10px';
                        listEl.parentElement.insertBefore(perfK, listEl);
                    }

                    const renderNeutral = (statusText) => {
                        perfK.innerHTML = '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">'
                          + '<div style="font-weight:600;color:#111827">Kronos 模型分数</div>'
                          + '<div style="font-size:12px;color:#6b7280">' + (statusText || '中性 · 置信度 --') + '</div>'
                          + '</div>'
                          + '<div style="height:8px;border-radius:999px;background:linear-gradient(90deg,#ef4444,#d1d5db,#10b981);position:relative;overflow:hidden">'
                          + '<div style="position:absolute;left:50%;transform:translateX(-50%);top:-4px;width:0;height:0;border-left:6px solid transparent;border-right:6px solid transparent;border-top:8px solid #111827;opacity:.5"></div>'
                          + '</div>';
                    };

                    if (!enabled) { renderNeutral('已关闭'); return; }

                    const sig = analysis?.signal || analysis || {};
                    const metaK = sig?.metadata?.kronos || analysis?.metadata?.kronos || null;
                    if (!metaK) { renderNeutral('无最近结果'); return; }

                    const clamp01 = v => Math.max(0, Math.min(1, Number(v) || 0));
                    const longS = clamp01(metaK.score_long);
                    const shortS = clamp01(metaK.score_short);
                    const conf = clamp01(metaK.confidence ?? 0.5);
                    const directional = longS - shortS;
                    const tiltPct = Math.round((directional + 1) * 50);
                    const dirText = directional > 0.05 ? '偏多' : (directional < -0.05 ? '偏空' : '中性');

                    // 分段条比例：空头(红)=shortS，中性=1-(longS+shortS)，多头(绿)=longS
                    let sR = shortS, sG = longS, sN = 1 - shortS - longS;
                    if (sN < 0) {
                        const sum = sR + sG;
                        if (sum > 0) { sR = sR / sum; sG = sG / sum; sN = 0; }
                        else { sR = 0; sG = 0; sN = 1; }
                    }
                    const redPct = (sR * 100).toFixed(2);
                    const neutralPct = (sN * 100).toFixed(2);
                    const greenPct = (sG * 100).toFixed(2);

                    perfK.innerHTML =
                        '<div style="display:flex;flex-wrap:wrap;gap:10px;justify-content:space-between;align-items:center;margin-bottom:6px">'
                        + '<div style="font-weight:600;color:#111827">Kronos 模型分数</div>'
                        + '<div style="display:flex;gap:10px;font-size:12px;color:#374151">'
                        + '<span>多头 ' + Math.round(longS * 100) + '</span>'
                        + '<span>空头 ' + Math.round(shortS * 100) + '</span>'
                        + '<span>置信度 ' + Math.round(conf * 100) + '%</span>'
                        + '<span>倾向 ' + dirText + '</span>'
                        + '</div>'
                        + '</div>'
                        + '<div style="height:8px;border-radius:999px;background:#e5e7eb;position:relative;overflow:hidden">'
                        +   '<div style="display:flex;height:100%;width:100%">'
                        +     '<div style="width:' + redPct + '%;background:#ef4444"></div>'
                        +     '<div style="width:' + neutralPct + '%;background:#d1d5db"></div>'
                        +     '<div style="width:' + greenPct + '%;background:#10b981"></div>'
                        +   '</div>'
                        + '<div style="position:absolute;left:' + tiltPct + '%;transform:translateX(-50%);top:-4px;width:0;height:0;border-left:6px solid transparent;border-right:6px solid transparent;border-top:8px solid #111827"></div>'
                        + '</div>';
                }).catch(_ => {});
            } catch (_) {}
        }

        // 加载性能数据
        async function loadPerformanceData() {
            try {
                const response = await fetch('/api/strategy/performance');
                const data = await response.json();
                
                if (data.success && data.data) {
                    const perf = data.data;
                    
                    // 安全地更新总收益率
                    const totalReturnEl = document.getElementById('totalReturn');
                    if (totalReturnEl) {
                        totalReturnEl.textContent = typeof perf.totalPnlPercent === 'number' 
                            ? (perf.totalPnlPercent).toFixed(2) + '%' 
                            : '0.00%';
                    }
                    
                    // 安全地更新胜率
                    const winRateEl = document.getElementById('winRate');
                    if (winRateEl) {
                        winRateEl.textContent = typeof perf.winRate === 'number' 
                            ? (perf.winRate * 100).toFixed(1) + '%' 
                            : '0.0%';
                    }
                    
                    // 安全地更新夏普比率
                    const sharpeRatioEl = document.getElementById('sharpeRatio');
                    if (sharpeRatioEl) {
                        sharpeRatioEl.textContent = typeof perf.sharpeRatio === 'number' 
                            ? perf.sharpeRatio.toFixed(2) 
                            : '0.00';
                    }
                    
                    // 安全地更新最大回撤
                    const maxDrawdownEl = document.getElementById('maxDrawdown');
                    if (maxDrawdownEl) {
                        maxDrawdownEl.textContent = typeof perf.maxDrawdown === 'number' 
                            ? (perf.maxDrawdown * 100).toFixed(2) + '%' 
                            : '0.00%';
                    }
                }
            } catch (error) {
                console.error('加载性能数据失败:', error);
            }
        }
        
        // 加载市场数据（增加重试与超时处理 + 内联状态提示）
        async function loadMarketData() {
            const priceEl = document.getElementById('currentPrice');
            const changeElLegacy = document.getElementById('priceChange');
            const changeSodEl = document.getElementById('marketChangeSod');
            // const changeEl = document.querySelector('#market-change'); // 已移除
            const volumeEl = document.getElementById('volume');
            const volEl = document.getElementById('volatility');
            const lowHighEl = document.getElementById('lowHigh24h');
            const fundingEl = document.getElementById('fundingRate');
            const statusEl = document.getElementById('marketInlineStatus');
            
            // 首先尝试使用缓存数据
            const cachedData = localStorage.getItem('marketDataCache');
            const cacheTimestamp = localStorage.getItem('marketDataCacheTime');
            const now = Date.now();
            
            // 如果缓存数据存在且未过期（5分钟内），先显示缓存数据
            if (cachedData && cacheTimestamp && (now - parseInt(cacheTimestamp)) < 5 * 60 * 1000) {
                try {
                    const cached = JSON.parse(cachedData);
                    updateMarketDataDOM(cached);
                    if (statusEl) {
                        statusEl.className = 'inline-status warn';
                        statusEl.textContent = '缓存数据 · ' + fmtTime(parseInt(cacheTimestamp));
                    }
                } catch (e) {
                    console.warn('缓存数据解析失败:', e);
                }
            }
            
            if (statusEl && !cachedData) {
                statusEl.className = 'inline-status warn';
                statusEl.textContent = '正在更新...';
            }
            
            try {
                // 增加重试次数和超时时间，提高成功率
                const data = await requestJsonWithRetry('/api/market/ticker?symbol=ETH-USDT-SWAP', {}, { retries: 3, timeoutMs: 8000, backoffMs: 1000 });
                if (data.success && data.data) {
                    const market = data.data;
                    
                    // 缓存成功获取的数据
                    localStorage.setItem('marketDataCache', JSON.stringify(market));
                    localStorage.setItem('marketDataCacheTime', now.toString());
                    
                    updateMarketDataDOM(market);
            
                    lastMarketOk = true;
                    lastMarketUpdate = Date.now();
                    if (statusEl) {
                        statusEl.className = 'inline-status ok';
                        statusEl.textContent = '在线 · ' + fmtTime(lastMarketUpdate);
                    }
                } else {
                    // API返回成功但数据为空，使用静态数据
                    throw new Error('API返回数据为空');
                }
                // 并行请求资金费率(8h)
                try {
                    const frRes = await fetch('/api/market/funding-rate?symbol=ETH-USDT-SWAP');
                    const frJson = await frRes.json();
                    const val = (typeof frJson?.data?.fundingRate === 'number') ? frJson.data.fundingRate : null;
                    if (fundingEl) {
                        fundingEl.textContent = (val === null || !isFinite(val)) ? '--' : (val * 100).toFixed(4) + '%';
                    }
                } catch (e) {
                    if (fundingEl) fundingEl.textContent = '--';
                }
            } catch (error) {
                console.error('加载市场数据失败:', error);
                
                // 如果有缓存数据，继续使用缓存数据
                if (cachedData && cacheTimestamp) {
                    try {
                        const cached = JSON.parse(cachedData);
                        updateMarketDataDOM(cached);
                        if (statusEl) {
                            statusEl.className = 'inline-status warn';
                            statusEl.textContent = '使用缓存 · ' + fmtTime(parseInt(cacheTimestamp));
                        }
                        return;
                    } catch (e) {
                        console.warn('缓存数据解析失败:', e);
                    }
                }
                
                // 先尝试回退：使用合约信息填充关键字段
                try {
                    const fallback = await requestJsonWithRetry('/api/market/contract?symbol=ETH-USDT-SWAP', {}, { retries: 1, timeoutMs: 2000, backoffMs: 400 });
                    if (fallback && fallback.success && fallback.data) {
                        updateDomWithMarketFallback(fallback.data);
                        lastMarketOk = true;
                        lastMarketUpdate = Date.now();
                        if (statusEl) {
                            statusEl.className = 'inline-status warn';
                            statusEl.textContent = '在线(降级) · ' + fmtTime(lastMarketUpdate);
                        }
                        return;
                    }
                } catch (fallbackErr) {
                    console.warn('回退获取合约信息失败:', fallbackErr);
                }
                // 回退也失败：不清空已有数值，提示离线并提供重试
                if (statusEl) {
                    statusEl.className = 'inline-status err';
                    statusEl.innerHTML = '离线 · 获取失败，<a href="#" onclick="refreshMarketData(); return false;">点击重试</a>' + (lastMarketUpdate ? (' · 上次更新 ' + fmtTime(lastMarketUpdate)) : '');
                }
                
                // 尝试使用静态数据填充市场数据区域
                updateDomWithStaticMarketData();
            }
        }
        
        // 提取市场数据DOM更新逻辑
        function updateMarketDataDOM(market) {
            const priceEl = document.getElementById('currentPrice');
            const changeElLegacy = document.getElementById('priceChange');
            const changeSodEl = document.getElementById('marketChangeSod');
            const volumeEl = document.getElementById('volume');
            const volEl = document.getElementById('volatility');
            const lowHighEl = document.getElementById('lowHigh24h');
            
            if (typeof market.price === 'number') priceEl.textContent = '$' + market.price.toFixed(2);
            // 统一仅展示 今日涨跌幅(UTC+8)
            let sodPct = null;
            if (typeof market.changeFromSodUtc8 === 'number') {
                sodPct = market.changeFromSodUtc8; // 首选：API字段
            } else if (typeof market.sodUtc8 === 'number' && typeof market.last === 'number' && market.sodUtc8 > 0) {
                sodPct = ((market.last - market.sodUtc8) / market.sodUtc8) * 100; // 回退：基于sodUtc8
            }
            if (changeElLegacy) {
                if (sodPct === null || !isFinite(sodPct)) {
                    changeElLegacy.textContent = '—';
                    changeElLegacy.style.color = '#6b7280';
                } else {
                    changeElLegacy.textContent = sodPct.toFixed(2) + '%';
                    changeElLegacy.style.color = sodPct >= 0 ? '#10b981' : '#ef4444';
                }
            }
            // 24h最低/最高
            if (lowHighEl) {
                const h24 = Number(market.high24h);
                const l24 = Number(market.low24h);
                if (isFinite(h24) && isFinite(l24)) {
                    lowHighEl.textContent = `$${l24.toFixed(2)} / $${h24.toFixed(2)}`;
                } else {
                    lowHighEl.textContent = '--';
                }
            }
            // 24h 成交额(按张折算, USDT) = volume(张) × price(USDT) × 0.1
            const volLots = Number(market.volume);
            const px = Number(typeof market.price === 'number' ? market.price : (market.last ?? market.price));
            const turnoverUSDT = (Number.isFinite(volLots) && Number.isFinite(px)) ? (volLots * px * 0.1) : NaN;
            volumeEl.textContent = Number.isFinite(turnoverUSDT) ? formatUSDT(turnoverUSDT) : '—';

            // 24h 振幅（高低区间/当前价），每10分钟计算一次，减少网络负担
            if (typeof window.__ampVal === 'undefined') { window.__ampVal = null; window.__ampTs = 0; }
            const now = Date.now();
            const ttl = 10 * 60 * 1000; // 10分钟
            const canUseCache = (typeof window.__ampVal === 'number' && isFinite(window.__ampVal) && (now - (window.__ampTs || 0) < ttl));

            if (canUseCache) {
                volEl.textContent = window.__ampVal.toFixed(2) + '%';
                volEl.classList.remove('loading-inline');
            } else {
                const h = Number(market.high24h);
                const l = Number(market.low24h);
                const p = Number(market.price ?? market.last);
                if (isFinite(h) && isFinite(l) && isFinite(p) && p > 0 && h >= l) {
                    const amp = Math.max(0, ((h - l) / p) * 100);
                    window.__ampVal = amp;
                    window.__ampTs = now;
                    volEl.textContent = amp.toFixed(2) + '%';
                    volEl.classList.remove('loading-inline');
                } else {
                    volEl.textContent = '加载中…';
                    volEl.classList.add('loading-inline');
                }
            }
        }
        
        // 使用静态数据更新市场数据区域
        function updateDomWithStaticMarketData() {
            const priceEl = document.getElementById('currentPrice');
            const changeSodEl = document.getElementById('marketChangeSod');
            const volumeEl = document.getElementById('volume');
            const volEl = document.getElementById('volatility');
            const lowHighEl = document.getElementById('lowHigh24h');
            const fundingEl = document.getElementById('fundingRate');
            
            // 使用静态数据
            if (priceEl && priceEl.textContent === '--') priceEl.textContent = '$4185.51';
            if (changeSodEl && changeSodEl.textContent === '--') {
                changeSodEl.textContent = '-0.04%';
                changeSodEl.style.color = '#ef4444';
            }
            if (volumeEl && volumeEl.textContent === '--') volumeEl.textContent = '25.5M';
            if (volEl && volEl.textContent === '--') volEl.textContent = '2.15%';
            if (lowHighEl && lowHighEl.textContent === '--') lowHighEl.textContent = '$4101.80 / $4302.70';
            if (fundingEl && fundingEl.textContent === '--') fundingEl.textContent = '0.0100%';
        }
        
        // 更新运行时间
        function updateUptime() {
            // 简单的运行时间计算
            const startTime = localStorage.getItem('systemStartTime');
            if (!startTime) {
                localStorage.setItem('systemStartTime', Date.now());
                return;
            }
            
            const uptime = Date.now() - parseInt(startTime);
            const hours = Math.floor(uptime / (1000 * 60 * 60));
            const minutes = Math.floor((uptime % (1000 * 60 * 60)) / (1000 * 60));
            const el = document.getElementById('uptime');
            if (el) el.textContent = `${hours}h ${minutes}m`;
        }
        
        // 刷新信号
        function refreshSignal() {
            loadLatestSignal();
        }
        
        // 刷新市场数据
        function refreshMarketData() {
            loadMarketData();
        }
        
        // 查看性能报告
        function viewPerformance() {
            window.open('/api/strategy/performance', '_blank');
        }
        
        // 查看风险管理
        function viewRiskManagement() {
            window.open('/api/risk/status', '_blank');
        }
        
        // 查看回测历史
        function viewBacktestHistory() {
            alert('回测历史功能开发中...');
        }
        

        // 加载开单推荐（脚本内）
        async function loadTradeRecommendation() {
            const container = document.getElementById('tradingRecommendation');
            if (!container) return;
            container.innerHTML = '<div class="loading">正在获取推荐信号...</div>';
            try {
                // 改为仅依赖 /api/active-recommendations
                const res = await fetch('/api/active-recommendations');
                const payload = await res.json();
                const d = payload?.data ?? payload;
                const list = Array.isArray(d?.recommendations)
                    ? d.recommendations
                    : Array.isArray(d)
                        ? d
                        : Array.isArray(d?.list)
                            ? d.list
                            : [];

                // 无活跃推荐：顶部红色横幅提示，推荐字段置空
                const hasActive = Array.isArray(list) && list.length > 0;
                if (!hasActive) {
                    container.innerHTML = '<div class="error">暂无推荐操作</div>';
                    const actionEl = document.getElementById('recommendedAction');
                    const entryEl = document.getElementById('entryPrice');
                    const levEl = document.getElementById('recommendedLeverage');
                    const posEl = document.getElementById('positionSizeRecommend');
                    if (actionEl) actionEl.textContent = '';
                    if (entryEl) entryEl.textContent = '';
                    if (levEl) levEl.textContent = '';
                    if (posEl) posEl.textContent = '';
                    window.__lastRecommendation = null;
                    return;
                }

                // 存在活跃推荐：渲染详细信息
                const latest = list
                    .slice()
                    .sort((a, b) => {
                        // 优先按 created_at 倒序，其次按 updated_at 倒序，防止旧单因心跳更新被排在最前
                        const ca = new Date(a?.created_at || 0).getTime();
                        const cb = new Date(b?.created_at || 0).getTime();
                        if (cb !== ca) return cb - ca;
                        const ua = new Date(a?.updated_at || 0).getTime();
                        const ub = new Date(b?.updated_at || 0).getTime();
                        return ub - ua;
                    })[0] || list[0];

                // 使用统一的字段映射逻辑
                const action = latest?.direction || latest?.action || '';
                const entry = latest?.entry_price || latest?.current_price || null;
                const leverage = latest?.leverage || null;
                const confidence = latest?.confidence_score || latest?.confidence || null;
                const takeProfit = latest?.take_profit_price || latest?.take_profit || null;
                const stopLoss = latest?.stop_loss_price || latest?.stop_loss || null;

                // 格式化显示
                const actionDisplay = String(action).toUpperCase();
                const entryDisplay = (typeof entry === 'number') ? '$' + entry.toFixed(2) : '--';
                const leverageDisplay = (typeof leverage === 'number') ? leverage + 'x' : '--';
                
                let confidenceDisplay = '--';
                if (typeof confidence === 'number') {
                    const conf = confidence <= 1 ? confidence * 100 : confidence;
                    confidenceDisplay = conf.toFixed(1) + '%';
                }
                
                const tpDisplay = (typeof takeProfit === 'number') ? '$' + takeProfit.toFixed(2) : '--';
                const slDisplay = (typeof stopLoss === 'number') ? '$' + stopLoss.toFixed(2) : '--';

                container.innerHTML = `
                    <div class="row"><span class="key">推荐操作</span><span class="val">${actionDisplay}</span></div>
                    <div class="row"><span class="key">入场价位</span><span class="val">${entryDisplay}</span></div>
                    <div class="row"><span class="key">推荐杠杆</span><span class="val">${leverageDisplay}</span></div>
                    <div class="row"><span class="key">置信度</span><span class="val">${confidenceDisplay}</span></div>
                    <div class="row"><span class="key">止盈/止损</span><span class="val">${tpDisplay} / ${slDisplay}</span></div>
                `;

                const actionEl = document.getElementById('recommendedAction');
                const entryEl = document.getElementById('entryPrice');
                const levEl = document.getElementById('recommendedLeverage');
                const posEl = document.getElementById('positionSizeRecommend');
                if (actionEl) actionEl.textContent = actionDisplay;
                if (entryEl) entryEl.textContent = entryDisplay;
                if (levEl) levEl.textContent = leverageDisplay;
                if (posEl) posEl.textContent = confidenceDisplay;

                window.__lastRecommendation = { 
                    action: actionDisplay, 
                    entry: entryDisplay, 
                    leverage: leverageDisplay, 
                    tp: tpDisplay, 
                    sl: slDisplay, 
                    conf: confidenceDisplay 
                };
            } catch (err) {
                console.error('加载开单推荐失败:', err);
                container.innerHTML = '<div class="error">推荐加载失败</div>';
            }
        }

        // 新增：开多/开空按钮（演示提示）
        function openLongPosition() {
            const rec = window.__lastRecommendation || {};
            alert(`准备开多:\n入场: ${formatPrice(rec.entry)}\n杠杆: ${formatLev(rec.leverage)}\n止盈: ${formatPrice(rec.tp)} / 止损: ${formatPrice(rec.sl)}`);
        }
        function openShortPosition() {
            const rec = window.__lastRecommendation || {};
            alert(`准备开空:\n入场: ${formatPrice(rec.entry)}\n杠杆: ${formatLev(rec.leverage)}\n止盈: ${formatPrice(rec.tp)} / 止损: ${formatPrice(rec.sl)}`);
        }
        function formatPrice(v){ return (typeof v === 'number') ? ('$' + v.toFixed(2)) : (v || '--'); }
        function formatLev(v){ return (typeof v === 'number') ? (v + 'x') : (v || '--'); }
        
        // 交易按钮状态控制：NONE/LONG/SHORT
        function setTradeButtonsState(direction){
            try{
                const btnLong = document.getElementById('btnLong');
                const btnShort = document.getElementById('btnShort');
                const dir = String(direction||'NONE').toUpperCase();
                if(!btnLong || !btnShort){ return; }
                if(dir === 'LONG'){
                    btnLong.disabled = false;
                    btnShort.disabled = true;
                } else if(dir === 'SHORT'){
                    btnLong.disabled = true;
                    btnShort.disabled = false;
                } else {
                    btnLong.disabled = true;
                    btnShort.disabled = true;
                }
            }catch(e){ /* 忽略 UI 状态异常 */ }
        }
        
        // 推荐历史相关功能
        let recommendationData = [];
        let filteredRecommendations = [];
        // 新增：分页状态
        let currentPage = 1;
        let pageSize = 5; // 恢复每页5条数据
        const selectedRecommendationIds = new Set();
        // 来自后端的真实总数与活跃数（优先用于统计展示）
        
        // 调试：添加全局变量监控
        window.debugRecommendations = () => {
            console.log('recommendationData:', recommendationData);
            console.log('filteredRecommendations:', filteredRecommendations);
            console.log('currentPage:', currentPage);
            console.log('pageSize:', pageSize);
        };
        let serverTotalRecommendations = null;
        let serverActiveRecommendationsCount = null;
        
        // 新增：获取当前页可见数据
        function getVisiblePageItems(){
            const total = filteredRecommendations.length;
            const totalPages = Math.max(1, Math.ceil(total / pageSize));
            if (currentPage > totalPages) currentPage = totalPages; // 越界容错
            const start = (currentPage - 1) * pageSize;
            const end = start + pageSize;
            const result = filteredRecommendations.slice(start, end);
            return result;
        }

        function updateDeleteButtonState() {
            const btn = document.getElementById('deleteSelectedBtn');
            if (!btn) return;
            const count = selectedRecommendationIds.size;
            btn.disabled = count === 0;
            btn.textContent = `删除所选(${count})`;
        }
        function resetHeaderCheckbox() {
            const headerCb = document.getElementById('selectAllRecs');
            if (!headerCb) return;
            const visibleIds = getVisiblePageItems().map(r => r.id).filter(Boolean);
            if (visibleIds.length === 0) {
                headerCb.checked = false;
                headerCb.indeterminate = false;
                return;
            }
            const selectedVisible = visibleIds.filter(id => selectedRecommendationIds.has(id));
            headerCb.checked = selectedVisible.length === visibleIds.length && visibleIds.length > 0;
            headerCb.indeterminate = selectedVisible.length > 0 && selectedVisible.length < visibleIds.length;
        }
        function toggleSelectAll(cb){
            const shouldSelect = cb?.checked;
            getVisiblePageItems().forEach(rec => {
                if (!rec?.id) return;
                if (shouldSelect) {
                    selectedRecommendationIds.add(rec.id);
                } else {
                    selectedRecommendationIds.delete(rec.id);
                }
            });
            renderRecommendationList();
            updateDeleteButtonState();
            resetHeaderCheckbox();
        }
        function onRowSelectChange(id, checked){
            if (!id) return;
            if (checked) selectedRecommendationIds.add(id); else selectedRecommendationIds.delete(id);
            updateDeleteButtonState();
            resetHeaderCheckbox();
        }
        
        // 加载推荐历史
        async function loadRecommendationHistory(preservePage = false) {
            const statusEl = document.getElementById('recommendationInlineStatus');
            const listEl = document.getElementById('recommendationList');
            
            // 并发保护：若正在加载，则仅设置尾随刷新标记并返回，避免 UI 闪烁
            if (window.__historyLoading) { window.__historyPending = true; return; }
            window.__historyLoading = true;
            
            if (statusEl) {
                statusEl.className = 'inline-status warn';
                statusEl.textContent = '正在更新...';
            }
            
            try {
                const statusFilterVal = document.getElementById('statusFilter')?.value || 'all';
                const includeActive = (statusFilterVal === 'ACTIVE' || statusFilterVal === 'all');
                const response = await fetch(`/api/recommendations?include_active=${includeActive}`, { cache: 'no-store' });
                const data = await response.json();
                
                // 兼容不同响应结构：
                // 1) { success: true, data: [...] }
                // 2) { success: true, data: { list: [...] , total, ... } }
                // 3) { list: [...] }
                const list = Array.isArray(data)
                  ? data
                  : Array.isArray(data?.data)
                    ? data.data
                    : Array.isArray(data?.data?.recommendations)
                      ? data.data.recommendations
                      : Array.isArray(data?.data?.list)
                        ? data.data.list
                        : Array.isArray(data?.list)
                          ? data.list
                          : [];
                // 读取后端总数（如果提供）
                serverTotalRecommendations =
                  (typeof data?.data?.total === 'number') ? data.data.total :
                  (typeof data?.total === 'number') ? data.total : null;
                
                if ((data?.success === true && list) || list.length > 0) {
                    // 历史列表去重（容错）：按“时间到秒 + 标的 + 方向(归一) + 关键价位(近似)”分组，组内保留最新/更高置信度
                    const bySig = new Map();
                    const normDir = (d) => {
                        const x = String(d || '').toUpperCase();
                        if (x === 'BUY') return 'LONG';
                        if (x === 'SELL') return 'SHORT';
                        return x;
                    };
                    const normNum = (v) => {
                        const n = Number(v);
                        if (!isFinite(n)) return '';
                        // 价格容差：保留两位小数做分组，避免微小浮点差异造成重复
                        return (Math.round(n * 100) / 100).toFixed(2);
                    };
                    for (const r of list) {
                        const t = new Date(r?.created_at || r?.createdAt || r?.create_time || r?.timestamp || 0).getTime();
                        const tBucket = isFinite(t) ? Math.floor(t / 5000) * 5000 : 0; // 5秒桶
                        const sym = String(r?.symbol || '').toUpperCase();
                        const dir = normDir(r?.direction || r?.action);
                        const entry = normNum(r?.entry_price);
                        const tp = normNum(r?.take_profit_price ?? r?.take_profit);
                        const sl = normNum(r?.stop_loss_price ?? r?.stop_loss);
                        const sig = `t${tBucket}|${sym}|${dir}|e${entry}|tp${tp}|sl${sl}`;
                        const prev = bySig.get(sig);
                        if (!prev) {
                            bySig.set(sig, r);
                        } else {
                            const tPrev = new Date(prev?.created_at || prev?.createdAt || prev?.create_time || prev?.timestamp || 0).getTime();
                            const newer = t > tPrev;
                            const conf = Number(r?.confidence ?? r?.conf ?? r?.confidence_score);
                            const pconf = Number(prev?.confidence ?? prev?.conf ?? prev?.confidence_score);
                            const betterConf = isFinite(conf) && (!isFinite(pconf) || conf > pconf);
                            if (newer || (!newer && betterConf)) bySig.set(sig, r);
                        }
                    }
                    const dedup = Array.from(bySig.values());
                    recommendationData = list; // 临时禁用去重逻辑，直接使用原始数据
                    filteredRecommendations = [...recommendationData];
                    
                    // 应用当前筛选和排序（自动刷新时保留页码）
                    filterRecommendations(preservePage);
                    sortRecommendations(preservePage);
                    
                    // 更新统计信息
                    await updateRecommendationStats();
                    
                    if (statusEl) {
                        statusEl.className = 'inline-status ok';
                        // 若后端提供 total，则显示 total，否则显示当前批次条数
                        const shown = (typeof serverTotalRecommendations === 'number') ? serverTotalRecommendations : recommendationData.length;
                        statusEl.textContent = `已加载 ${shown} 条（当前批次 ${recommendationData.length}）`;
                    }
                    // 清空占位内容（如果存在）
                    if (listEl && listEl.innerHTML && listEl.innerHTML.includes('正在加载推荐记录')) {
                        listEl.innerHTML = '';
                    }

                } else {
                    if (listEl) {
                        listEl.innerHTML = '<div class="error">暂无推荐记录</div>';
                    }
                    if (statusEl) {
                        statusEl.className = 'inline-status warn';
                        statusEl.textContent = '暂无数据';
                    }
                }
            } catch (error) {
                console.error('加载推荐历史失败:', error);
                if (listEl) {
                    listEl.innerHTML = '<div class="error">加载失败，请稍后重试</div>';
                }
                if (statusEl) {
                    statusEl.className = 'inline-status err';
                    statusEl.textContent = '加载失败';
                }
            } finally {
                window.__historyLoading = false;
                if (window.__historyPending) {
                    window.__historyPending = false;
                    setTimeout(() => loadRecommendationHistory(true), 80);
                }
            }
        }
        
        // 渲染推荐列表到表格（支持分页）
        function renderRecommendationList() {
            const tableBodyEl = document.getElementById('recommendationTableBody');
            if (!tableBodyEl) return;
            
            if (filteredRecommendations.length === 0) {
                tableBodyEl.innerHTML = '<tr><td colspan="11" class="loading">暂无符合条件的推荐记录</td></tr>';
                renderPagination();
                resetHeaderCheckbox();
                return;
            }
            const pageItems = getVisiblePageItems();
            if (pageItems.length === 0) {
                currentPage = Math.max(1, currentPage - 1);
                return renderRecommendationList();
            }
            
            const html = pageItems.map(rec => {
                const dt = new Date(rec.created_at || rec.timestamp);
                const time = dt.toLocaleString('zh-CN', {
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false
                });
                const iso = dt.toISOString();
                const actionRaw = rec.direction || rec.action || 'HOLD';
                const action = String(actionRaw).toUpperCase();
                const status = rec.status || 'PENDING';
                const pnl = (typeof rec.pnl_percent === 'number') ? rec.pnl_percent : ((typeof rec.pnl_percentage === 'number') ? rec.pnl_percentage : null);
                const hasPnl = (typeof pnl === 'number') && Number.isFinite(pnl);
                const pnlClass = hasPnl ? (pnl > 0 ? 'positive' : pnl < 0 ? 'negative' : '') : '';
                const confidence = rec.confidence_score || rec.confidence || 0;
                const accent = action === 'LONG' ? 'accent-long' : (action === 'SHORT' ? 'accent-short' : 'accent-hold');
                const isChecked = rec.id ? selectedRecommendationIds.has(rec.id) : false;
                
                // 状态显示映射
                const statusMap = {
                    'PENDING': '待确认',
                    'ACTIVE': '进行中',
                    'CLOSED': '已平仓',
                    'EXPIRED': '已过期'
                };
                
                // 出场原因映射
                const reasonMap = {
                    'TIMEOUT': '超时',
                    'TAKE_PROFIT': '止盈',
                    'STOP_LOSS': '止损',
                    'MANUAL': '手动',
                    'BREAKEVEN': '保本',
                    'LIQUIDATION': '爆仓'
                };
                const reasonRaw = (rec.exit_reason || '').toUpperCase();
                let statusText = statusMap[status] || status;
                let reasonBadgeHtml = '';
                if (status === 'CLOSED' || status === 'EXPIRED') {
                    if (status === 'EXPIRED') {
                        statusText = '已平仓';
                        reasonBadgeHtml = `<span class="reason-badge">超时（历史）</span>`;
                    } else {
                        // 优化：对 "止损" 在正收益或保本区间内的场景做更友好的说明
                        let reasonText = reasonMap[reasonRaw];
                        if (reasonRaw === 'STOP_LOSS') {
                            if (typeof pnl === 'number' && pnl > 0.05) {
                                reasonText = '动态止盈';
                            } else if (typeof pnl === 'number' && Math.abs(pnl) <= 0.05) {
                                reasonText = '保本止损';
                            }
                        }
                        if (reasonText) reasonBadgeHtml = `<span class="reason-badge">${reasonText}</span>`;
                    }
                }
                
                return `
                    <tr class="recommendation-row ${status.toLowerCase()} ${accent}">
                        <td style="text-align:center"><input type="checkbox" ${isChecked ? 'checked' : ''} ${rec.id ? '' : 'disabled'} onchange="onRowSelectChange('${rec.id ?? ''}', this.checked)"/></td>
                        <td title="${iso}">${time}</td>
                        <td><span class="action-badge ${action.toLowerCase()}">${action}</span></td>
                        <td>${formatPrice(rec.entry_price)}</td>
                        <td>${formatLev(rec.leverage)}</td>
                        <td>${formatPrice(rec.take_profit_price || rec.take_profit)}</td>
                        <td>${formatPrice(rec.stop_loss_price || rec.stop_loss)}</td>
                        <td>${confidence ? (confidence <= 1 ? (confidence * 100).toFixed(1) : confidence.toFixed(1)) + '%' : '--'}</td>
                        <td><span class="status-badge ${status.toLowerCase()}">${statusText}</span>${reasonBadgeHtml}</td>
                        <td>${(status === 'CLOSED' || status === 'EXPIRED') ? formatPrice(rec.exit_price) : '--'}</td>
                        <td><span class="pnl-value ${pnlClass}">${hasPnl ? (pnl > 0 ? '+' : '') + pnl.toFixed(2) + '%' : '--'}</span></td>
                    </tr>
                `;
            }).join('');
            
            tableBodyEl.innerHTML = html;
            try { renderTimeInsights(); } catch(_) {}
            renderPagination();
            resetHeaderCheckbox();
        }
        
        // 时间洞察：近24小时小时分布 + 5秒内聚类
        function renderTimeInsights(){
            const container = document.getElementById('timeInsights');
            if(!container) return;
            const source = Array.isArray(filteredRecommendations) && filteredRecommendations.length>0 ? filteredRecommendations : (Array.isArray(recommendationData)?recommendationData:[]);
            if(!Array.isArray(source) || source.length===0){ container.innerHTML=''; return; }
            const now = Date.now();
            const start = now - 24*3600*1000;
            const ts = source.map(r=> new Date(r?.created_at||r?.timestamp).getTime()).filter(t=> Number.isFinite(t) && t>0);
            const ts24 = ts.filter(t=> t>=start).sort((a,b)=>a-b);
            // 5秒簇
            let clusters=0, maxSize=1, run=1;
            for(let i=1;i<ts24.length;i++){
                if(ts24[i]-ts24[i-1] <= 5000){ run++; } else { if(run>=2) clusters++; if(run>maxSize) maxSize=run; run=1; }
            }
            if(run>=2) clusters++; if(run>maxSize) maxSize=Math.max(maxSize, run);
            // 小时桶
            const buckets = new Array(24).fill(0);
            ts24.forEach(t=>{ const h=new Date(t).getHours(); buckets[h]++; });
            const max = Math.max(1, ...buckets);
            const cells = buckets.map((c,i)=>{
                const alpha = (0.15 + 0.85*(c/max)).toFixed(2);
                const bg = `rgba(51,102,204,${alpha})`;
                const title = `${String(i).padStart(2,'0')}:00 - ${String(i).padStart(2,'0')}:59 · ${c}条`;
                return `<div title="${title}" style="flex:1;height:16px;margin:0 1px;border-radius:3px;background:${bg}"></div>`;
            }).join('');
            const tz = (Intl.DateTimeFormat().resolvedOptions().timeZone||'本地');
            const info = `近24小时 ${ts24.length} 条 · 5秒内聚类 ${clusters} 组（最大 ${maxSize} 条）`;
            container.innerHTML = `<div style="display:flex;align-items:center;justify-content:space-between;margin:8px 0 4px 0;font-size:12px;color:#6b7280"><div>${info}</div><div style="color:#9ca3af">时间精度：5秒 · 时区：${tz}</div></div><div style="display:flex;align-items:center;margin:4px 0">${cells}</div>`;
            const statusEl = document.getElementById('recommendationInlineStatus');
            if(statusEl){ statusEl.className='inline-status ok'; statusEl.textContent='已加载 · 5秒时间'; }
        }
        
        // 筛选推荐（可选：保留当前页）
        function filterRecommendations(preservePage = false) {
            const statusFilter = document.getElementById('statusFilter')?.value || 'all';
            
            // 当用户切换到“进行中”时，如果当前数据源不含活跃项，则重新拉取（包含活跃）
            if (statusFilter === 'ACTIVE') {
                const hasActiveInData = Array.isArray(recommendationData) && recommendationData.some(rec => rec?.status === 'ACTIVE' || rec?.status === 'PENDING');
                if (!hasActiveInData) {
                    loadRecommendationHistory(true); // loadRecommendationHistory 会根据当前筛选动态 include_active
                    return; // 等待数据刷新后再渲染
                }
            } else if (statusFilter === 'CLOSED') {
                // 切回“已平仓”时，为避免与上方活跃区重复，确保数据源不包含活跃项
                const hasActiveInData = Array.isArray(recommendationData) && recommendationData.some(rec => rec?.status === 'ACTIVE' || rec?.status === 'PENDING');
                if (hasActiveInData) {
                    loadRecommendationHistory(true); // 动态 include_active=false（因当前筛选为 CLOSED）
                    return; // 等待数据刷新后再渲染
                }
            } else {
                // statusFilter === 'all'：允许数据源包含活跃项，不再触发二次拉取，避免刷新抖动
            }
            
            if (statusFilter === 'all') {
                // 全部状态：前端不过滤，数据源已包含活跃项（见 loadRecommendationHistory 判定）
                filteredRecommendations = [...recommendationData];
            } else if (statusFilter === 'ACTIVE') {
                filteredRecommendations = recommendationData.filter(rec => rec.status === 'ACTIVE' || rec.status === 'PENDING');
            } else if (statusFilter === 'CLOSED') {
                // 将历史 EXPIRED 折叠归为已平仓
                filteredRecommendations = recommendationData.filter(rec => rec.status === 'CLOSED' || rec.status === 'EXPIRED');
            } else {
                filteredRecommendations = recommendationData.filter(rec => rec.status === statusFilter);
            }
            if (!preservePage) currentPage = 1;
            renderRecommendationList();
            try { renderTimeInsights(); } catch(_) {}
        }
        
        // 排序推荐（可选：保留当前页）
        function sortRecommendations(preservePage = false) {
            const sortBy = document.getElementById('sortBy')?.value || 'created_at';
            const sortOrder = document.getElementById('sortOrder')?.value || 'desc';
            
            filteredRecommendations.sort((a, b) => {
                let aVal, bVal;
                
                switch (sortBy) {
                    case 'created_at':
                        aVal = new Date(a.created_at || a.timestamp);
                        bVal = new Date(b.created_at || b.timestamp);
                        break;
                    case 'pnl_percent':
                        aVal = a.pnl_percent || a.pnl_percentage || 0;
                        bVal = b.pnl_percent || b.pnl_percentage || 0;
                        break;
                    case 'confidence_score':
                        aVal = a.confidence_score || a.confidence || 0;
                        bVal = b.confidence_score || b.confidence || 0;
                        break;
                    default:
                        return 0;
                }
                
                if (sortOrder === 'asc') {
                    return aVal > bVal ? 1 : aVal < bVal ? -1 : 0;
                } else {
                    return aVal < bVal ? 1 : aVal > bVal ? -1 : 0;
                }
            });
            if (!preservePage) currentPage = 1;
            renderRecommendationList();
            try { renderTimeInsights(); } catch(_) {}
        }
        
        // 新增：渲染分页
        function renderPagination(){
            const el = document.getElementById('recommendationPagination');
            if (!el) return;
            const total = filteredRecommendations.length;
            const totalPages = Math.max(1, Math.ceil(total / pageSize));
            const maxShown = 5;
            let start = Math.max(1, currentPage - Math.floor(maxShown/2));
            let end = Math.min(totalPages, start + maxShown - 1);
            start = Math.max(1, Math.min(start, Math.max(1, end - maxShown + 1)));

            const pageNumbers = [];
            for (let p = start; p <= end; p++) {
                pageNumbers.push(`<button class="page-number ${p===currentPage?'active':''}" onclick="goToPage(${p})">${p}</button>`);
            }

            el.innerHTML = `
                <button class="page-btn" onclick="goToPage(${currentPage-1})" ${currentPage<=1?'disabled':''}>上一页</button>
                ${pageNumbers.join('')}
                <button class="page-btn" onclick="goToPage(${currentPage+1})" ${currentPage>=totalPages?'disabled':''}>下一页</button>
                <span class="page-info">共 ${total} 条 · 每页 ${pageSize} 条 · 第 ${currentPage}/${totalPages} 页</span>
            `;
        }

        // 新增：翻页函数
        function goToPage(p){
            const totalPages = Math.max(1, Math.ceil(filteredRecommendations.length / pageSize));
            currentPage = Math.min(Math.max(1, p), totalPages);
            renderRecommendationList();
        }
        window.goToPage = goToPage;
        
        // 统一去重函数：按历史列表规则去重（时间桶+标的+方向+关键价位）
        function dedupRecommendationsByHistoryRule(list) {
            const bySig = new Map();
            const normDir = (d) => {
                const x = String(d || '').toUpperCase();
                if (x === 'BUY') return 'LONG';
                if (x === 'SELL') return 'SHORT';
                return x;
            };
            const normNum = (v) => {
                const n = Number(v);
                if (!isFinite(n)) return '';
                // 价格容差：保留两位小数做分组，避免微小浮点差异造成重复
                return (Math.round(n * 100) / 100).toFixed(2);
            };
            for (const r of list) {
                const t = new Date(r?.created_at || r?.createdAt || r?.create_time || r?.timestamp || 0).getTime();
                const tBucket = isFinite(t) ? Math.floor(t / 5000) * 5000 : 0; // 5秒桶
                const sym = String(r?.symbol || '').toUpperCase();
                const dir = normDir(r?.direction || r?.action);
                const entry = normNum(r?.entry_price);
                const tp = normNum(r?.take_profit_price ?? r?.take_profit);
                const sl = normNum(r?.stop_loss_price ?? r?.stop_loss);
                const sig = `t${tBucket}|${sym}|${dir}|e${entry}|tp${tp}|sl${sl}`;
                const prev = bySig.get(sig);
                if (!prev) {
                    bySig.set(sig, r);
                } else {
                    const tPrev = new Date(prev?.created_at || prev?.createdAt || prev?.create_time || prev?.timestamp || 0).getTime();
                    const newer = t > tPrev;
                    const conf = Number(r?.confidence ?? r?.conf ?? r?.confidence_score);
                    const pconf = Number(prev?.confidence ?? prev?.conf ?? prev?.confidence_score);
                    const betterConf = isFinite(conf) && (!isFinite(pconf) || conf > pconf);
                    if (newer || (!newer && betterConf)) bySig.set(sig, r);
                }
            }
            return Array.from(bySig.values());
        }

        // 更新推荐统计（使用后端真实 total/active、综合统计中的胜率与平均收益）
        async function updateRecommendationStats() {
            const total = (typeof serverTotalRecommendations === 'number') ? serverTotalRecommendations : recommendationData.length;
            // 异步获取真实活跃数（兼容 {data:{recommendations, count}} 结构）
            let rawActiveList = [];
            try {
                const res = await fetch('/api/active-recommendations');
                if (res.ok) {
                    const act = await res.json();
                    const payload = act?.data ?? act;
                    const arr = Array.isArray(payload?.recommendations)
                        ? payload.recommendations
                        : Array.isArray(payload)
                            ? payload
                            : Array.isArray(payload?.list)
                                ? payload.list
                                : [];
                    rawActiveList = Array.isArray(arr) ? arr : [];
                    // 原始数量（后端返回）
                    serverActiveRecommendationsCount = rawActiveList.length;
                }
            } catch(e) {
                console.warn('获取活跃推荐失败，回退到本地统计', e);
            }
            // 应用统一去重规则计算活跃数量
            const dedupActiveList = rawActiveList.length > 0 ? dedupRecommendationsByHistoryRule(rawActiveList) : [];
            const active = dedupActiveList.length > 0 
                ? dedupActiveList.length
                : recommendationData.filter(rec => rec.status === 'ACTIVE' || rec.status === 'active').length;

            // 胜率与平均收益优先读取综合统计接口（全量已平仓口径），失败回退到本地样本
            let winRateFromServer = null;
            let avgPnlFromServer = null;
            try {
                const res2 = await fetch('/api/statistics/overall');
                if (res2.ok) {
                    const ov = await res2.json();
                    const d = ov?.data ?? ov;
                    if (typeof d?.overall_win_rate === 'number') winRateFromServer = d.overall_win_rate;
                    if (typeof d?.overall_avg_pnl === 'number') avgPnlFromServer = d.overall_avg_pnl;
                    // 若此前未获得 total/active，可从统计接口补齐
                    if (typeof serverTotalRecommendations !== 'number' && typeof d?.total_recommendations === 'number') {
                        serverTotalRecommendations = d.total_recommendations;
                    }
                    if (typeof serverActiveRecommendationsCount !== 'number' && typeof d?.active_recommendations === 'number') {
                        serverActiveRecommendationsCount = d.active_recommendations;
                    }
                }
            } catch (e) {
                console.warn('获取综合统计失败，回退到本地样本统计', e);
            }

            const completed = recommendationData.filter(rec => rec.status === 'CLOSED' || rec.status === 'completed');
            const localWinRate = completed.length > 0 ? 
                (completed.filter(rec => (rec.pnl_percent || rec.pnl_percentage || 0) > 0).length / completed.length * 100) : 0;
            const localAvgPnl = completed.length > 0 ? 
                (completed.reduce((sum, rec) => sum + (rec.pnl_percent || rec.pnl_percentage || 0), 0) / completed.length) : 0;
            const winRate = (typeof winRateFromServer === 'number') ? winRateFromServer : localWinRate;
            const avgPnl = (typeof avgPnlFromServer === 'number') ? avgPnlFromServer : localAvgPnl;
            
            document.getElementById('totalRecommendations').textContent = total;
            document.getElementById('activeRecommendations').textContent = active;
            document.getElementById('winRateRecommendations').textContent = `${winRate.toFixed(1)}%`;
            document.getElementById('avgPnlRecommendations').textContent = `${avgPnl.toFixed(2)}%`;
        }
        
        // 刷新推荐历史（保留当前页）
        function refreshRecommendations() { loadRecommendationHistory(true); }
        
        // 批量删除所选推荐
        async function deleteSelectedRecommendations(){
            const ids = Array.from(selectedRecommendationIds);
            if (ids.length === 0) return;
            if (!confirm(`确认删除选中的 ${ids.length} 条记录？此操作不可撤销。`)) return;
            const statusEl = document.getElementById('recommendationInlineStatus');
            if (statusEl) {
                statusEl.className = 'inline-status warn';
                statusEl.textContent = '正在删除...';
            }
            document.getElementById('deleteSelectedBtn')?.setAttribute('disabled','true');
            // 逐个调用后端删除接口
            const results = await Promise.allSettled(ids.map(id => fetch(`/api/recommendations/${id}`, { method: 'DELETE' })));
            let ok = 0, fail = 0;
            for (const r of results) {
                if (r.status === 'fulfilled' && r.value?.ok) ok++; else fail++;
            }
            // 清理选择 & 刷新
            selectedRecommendationIds.clear();
            updateDeleteButtonState();
            await loadRecommendationHistory(true);
            // 确保统计同步服务端
            await updateRecommendationStats();
            if (statusEl) {
                statusEl.className = fail === 0 ? 'inline-status ok' : 'inline-status warn';
                statusEl.textContent = fail === 0 ? '删除完成' : `部分删除失败 (${ok}/${ids.length})`;
            }
            if (fail > 0) {
                alert(`删除完成：成功 ${ok} 条，失败 ${fail} 条。`);
            }
        }
        
        // 启动策略
        async function startStrategy() {
            try {
                const response = await fetch('/api/strategy/start', { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    alert('策略启动成功！');
                    loadSystemStatus();
                } else {
                    alert('策略启动失败: ' + data.error);
                }
            } catch (error) {
                alert('请求失败: ' + error.message);
            }
        }
        
        // 停止策略
        async function stopStrategy() {
            try {
                const response = await fetch('/api/strategy/stop', { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    alert('策略已停止！');
                    loadSystemStatus();
                } else {
                    alert('策略停止失败: ' + data.error);
                }
            } catch (error) {
                alert('请求失败: ' + error.message);
            }
        }
        
        // 重启策略
        async function restartStrategy() {
            if (confirm('确定要重启策略吗？')) {
                await stopStrategy();
                setTimeout(() => {
                    startStrategy();
                }, 2000);
            }
        }
        
        // 页面卸载时清理
        window.onbeforeunload = function() {
            if (updateInterval) {
                clearInterval(updateInterval);
            }
            if (window.__slippageTimer) {
                clearInterval(window.__slippageTimer);
            }
        };
    </script>
    <script>
    (function(){
      if (window.__ACTIVE_UI_PATCHED__) return; // 防重复注入
      window.__ACTIVE_UI_PATCHED__ = true;
      if (typeof window.loadTradeRecommendation === 'function') {
        window.__legacyLoadTradeRecommendation = window.loadTradeRecommendation;
      }
      const AUTO_MS_DEFAULT = 30000;
      function ensureActiveStyles(){
        if(document.getElementById('active-styles')) return;
        const style=document.createElement('style');
        style.id='active-styles';
        style.textContent = `
        .active-bar{display:flex;align-items:center;justify-content:space-between;padding:8px 10px;border:1px solid #e8e8e8;border-radius:8px;background:#fafafa;margin-bottom:10px}
        .active-bar .left{display:flex;align-items:center;gap:8px}
        .active-bar .right{display:flex;align-items:center;gap:8px}
        .active-bar .label{color:#555}
        .active-bar .strong{font-weight:600}
        .active-bar .muted{color:#888}
        .active-bar .sep{color:#ddd}
        .active-bar .countdown{font-variant-numeric:tabular-nums;color:#333}
        .active-bar .dot{width:8px;height:8px;border-radius:50%;display:inline-block}
        .active-bar .dot.on{background:#2ecc71}
        .active-bar .dot.off{background:#e74c3c}
        .btn.small{padding:6px 10px;font-size:12px;border-radius:6px;border:1px solid #ddd;background:#fff;cursor:pointer;color:#2980b9}
.btn.small:hover{background:#f4f4f4}
        .btn.danger{border-color:#ffb4b4;color:#c0392b}
        .btn.danger:hover{background:#ffecec}
        .rec-list{display:flex;flex-direction:column;gap:16px}
        .rec-item{display:flex;align-items:stretch;justify-content:space-between;gap:16px;border:1px solid #eaeaea;border-radius:12px;padding:14px 16px;background:#fff;box-shadow:0 1px 0 rgba(0,0,0,0.03)}
        .rec-item .col.main{flex:1}
        .rec-item .title{display:flex;align-items:center;gap:10px;margin-bottom:10px}
        .rec-item .symbol{font-weight:600}
        .rec-item .muted{color:#888;font-size:12px}
        .rec-item .grid{display:grid;grid-template-columns:repeat(3,minmax(140px,1fr));gap:10px 14px}
        .rec-item .k{color:#666;margin-right:6px}
        .rec-item .v{font-variant-numeric:tabular-nums;line-height:1.5}
        .rec-item.skeleton{min-height:140px}
        .rec-item.skeleton .v{color:#bbb}
        .badge{padding:2px 6px;border-radius:6px;background:#eef;border:1px solid #dde;font-size:12px}
        .badge.long{background:#eafff3;border-color:#c4f2d8;color:#1e874b}
        .badge.short{background:#fff0f0;border-color:#ffd6d6;color:#b03a2e}
        .diff-blink{animation: diffFlash 1.2s ease-in-out 1}
        @keyframes diffFlash{0%{background:transparent}30%{background:#fff6cc}100%{background:transparent}}
        .empty-tip{padding:10px 12px;color:#666}
        @media (max-width: 560px){.rec-item{flex-direction:column}}
        .loading{padding:8px 10px;color:#666}
        .error{padding:8px 10px;color:#b03a2e}
        .alert{padding:10px 12px;border-radius:8px;margin:10px 0;font-size:14px}
        .alert-danger{background:#fff0f0;border:1px solid #ffd6d6;color:#b03a2e}
        `;
        document.head.appendChild(style);
      }
      function renderTopBar(count){
        const nextAt = Date.now() + (window.__AUTO_REFRESH_INTERVAL_MS||AUTO_MS_DEFAULT);
        window.__nextAutoRefreshAt = nextAt;
        return `<div class="active-bar" id="activeSignalBar">
          <div class="left">
            <span class="dot ${count>0?'on':'off'}"></span>
            <span class="label">活跃信号</span>
            <span class="strong" id="activeSignalCount">${count}</span>
            <span class="sep">|</span>
            <span class="muted">下次自动刷新</span>
            <span class="countdown" id="nextRefreshCountdown">${Math.round((nextAt-Date.now())/1000)}s</span>
          </div>
          <div class="right">
            <button id="btnManualRefresh" class="btn small">刷新</button>
          </div>
        </div>`;
      }
      function ensureAutoRefreshTicker(){
        if (window.__autoRefreshTickTimer) clearInterval(window.__autoRefreshTickTimer);
        window.__autoRefreshTickTimer = setInterval(()=>{
          const el = document.getElementById('nextRefreshCountdown');
          if(!el||!window.__nextAutoRefreshAt) return;
          const remain=Math.max(0,Math.round((window.__nextAutoRefreshAt-Date.now())/1000));
          el.textContent = `${remain}s`;
        },1000);
      }
      function scheduleAutoRefresh(){
        const ms = window.__AUTO_REFRESH_INTERVAL_MS||AUTO_MS_DEFAULT;
        if (window.__nextRefreshTimer) clearTimeout(window.__nextRefreshTimer);
        window.__nextRefreshTimer = setTimeout(()=>{
          try { window.loadTradeRecommendation(); } catch(e){}
        }, ms);
      }
      function parseActiveList(d){
        const list = Array.isArray(d?.recommendations) ? d.recommendations : Array.isArray(d) ? d : Array.isArray(d?.list) ? d.list : [];
        return Array.isArray(list) ? list.filter(Boolean) : [];
      }
      // 新增：解析历史推荐列表
      function parseHistoryList(d){
        const data = d?.data ?? d;
        const arr = Array.isArray(data?.recommendations)
          ? data.recommendations
          : Array.isArray(data?.list)
            ? data.list
            : Array.isArray(data)
              ? data
              : [];
        return Array.isArray(arr) ? arr.filter(Boolean) : [];
      }
      // 新增：避免点击历史时间抛错，暂不启用锁定逻辑，始终显示最新
      function lockRecommendation(id){ try{ window.scrollTo({top:0, behavior:'smooth'});}catch(e){} window.__lockedRecommendationId = null; window.loadTradeRecommendation?.(); }
      function fmtPrice(v){ return (typeof v === 'number') ? ('$' + v.toFixed(2)) : (v ?? '--'); }
      function fmtLev(v){ return (typeof v === 'number') ? (v + 'x') : (v ?? '--'); }
      function fmtPct(v){ if (typeof v === 'number') return `${v<=1?(v*100).toFixed(1):v.toFixed(1)}%`; if (typeof v === 'string' && v.endsWith('%')) return v; return '--'; }
      function formatRelative(ts){ if (!ts) return '--'; const t = (ts instanceof Date) ? ts.getTime() : new Date(ts).getTime(); if (!Number.isFinite(t)) return '--'; const s = Math.max(0, Math.floor((Date.now()-t)/1000)); if (s<60) return `${s}s前`; const m=Math.floor(s/60); if(m<60) return `${m}分钟前`; const h=Math.floor(m/60); if(h<24) return `${h}小时前`; const d=Math.floor(h/24); return `${d}天前`; }
      function clearItemTimers(){ /* removed per 方案A: no per-item TTL countdown */ }
      function startItemCountdown(){ /* removed per 方案A: no per-item TTL countdown */ }
      function diffHighlight(id,current){ const prev = (window.__lastActiveSnapshot||{})[id]; if(!window.__lastActiveSnapshot) window.__lastActiveSnapshot={}; window.__lastActiveSnapshot[id] = { direction: current.direction, entry_price: current.entry_price, take_profit_price: current.take_profit_price ?? current.take_profit, stop_loss_price: current.stop_loss_price ?? current.stop_loss, leverage: current.leverage, position_size: current.position_size }; if(!prev) return; ['direction','entry_price','take_profit_price','stop_loss_price','leverage','position_size'].forEach(k=>{ const pv=prev[k], cv=window.__lastActiveSnapshot[id][k]; if(String(pv)!==String(cv)){ const el=document.querySelector(`[data-field="${k}-${id}"]`); if(el){ el.classList.add('diff-blink'); setTimeout(()=>el.classList.remove('diff-blink'),1600); } } }); }

      window.loadTradeRecommendation = async function(){
        const container = document.getElementById('tradingRecommendation');
        if (!container) return;
        ensureActiveStyles();
        if (typeof window.__AUTO_REFRESH_INTERVAL_MS !== 'number') window.__AUTO_REFRESH_INTERVAL_MS = AUTO_MS_DEFAULT;
        container.innerHTML = '<div class="loading">正在获取推荐信号...</div>';
        try {
          const res = await fetch('/api/active-recommendations',{cache:'no-store'});
          const payload = await res.json();
          const d = payload?.data ?? payload;
          const list = parseActiveList(d);
          const dedupList = Array.isArray(list) ? dedupRecommendationsByHistoryRule(list) : [];
          const hasActive = dedupList.length>0;
          const topBar = renderTopBar(dedupList.length);
          if(!hasActive){
            clearItemTimers(); ensureAutoRefreshTicker(); scheduleAutoRefresh();
            const a=document.getElementById('recommendedAction');
            const e=document.getElementById('entryPrice');
            const l=document.getElementById('recommendedLeverage');
            const p=document.getElementById('positionSizeRecommend');
            if(a) a.textContent=''; if(e) e.textContent=''; if(l) l.textContent=''; if(p) p.textContent=''; window.__lastRecommendation=null;
            container.innerHTML = `${topBar}<div class=\"alert alert-danger\">当前价格暂无开单推荐</div><div class=\"rec-list\" id=\"activeSignalList\"><div class=\"rec-item skeleton\"><div class=\"col main\"><div class=\"title\"><span class=\"badge\">--</span><span class=\"symbol\">ETH-USDT-SWAP</span></div><div class=\"grid\"><div><span class=\"k\">入场</span> <span class=\"v\">--</span></div><div><span class=\"k\">杠杆</span> <span class=\"v\">--</span></div><div><span class=\"k\">预期收益</span> <span class=\"v\">--</span></div><div><span class=\"k\">止损</span> <span class=\"v\">--</span></div><div><span class=\"k\">止盈</span> <span class=\"v\">--</span></div><div><span class=\"k\">置信度</span> <span class=\"v\">--</span></div></div></div></div></div>`
            try{ setTradeButtonsState('NONE'); }catch(_){ }
            const btn=document.getElementById('btnManualRefresh'); if(btn) btn.onclick=()=>{ window.loadTradeRecommendation(); };
            return;
          }
          // 仅使用活跃推荐（去重后），并按创建时间倒序取最新
          let sorted = dedupList.slice().sort((a,b)=>{ const ca=new Date(a?.created_at||a?.createdAt||a?.create_time||0).getTime(); const cb=new Date(b?.created_at||b?.createdAt||b?.create_time||0).getTime(); if(cb!==ca) return cb-ca; const ua=new Date(a?.updated_at||a?.updatedAt||0).getTime(); const ub=new Date(b?.updated_at||b?.updatedAt||0).getTime(); return ub-ua; });
          const itemsHtml = sorted.slice(0,1).map(rec=>{ const id=rec.id||rec._id||rec.uuid||''; const symbol=rec.symbol||'ETH-USDT-SWAP'; const direction=String(rec.direction||rec.action||'').toUpperCase(); const entry=(typeof rec.entry_price==='number')?rec.entry_price:(typeof rec.current_price==='number'?rec.current_price:null); const lev=(typeof rec.leverage==='number')?rec.leverage:null; const confRaw=(typeof rec.confidence_score==='number')?rec.confidence_score:(typeof rec.confidence==='number'?rec.confidence:null); const conf=(typeof confRaw==='number')?((confRaw<=1?confRaw*100:confRaw)):null; const tp=(typeof rec.take_profit_price==='number')?rec.take_profit_price:(typeof rec.take_profit==='number'?rec.take_profit:null); const sl=(typeof rec.stop_loss_price==='number')?rec.stop_loss_price:(typeof rec.stop_loss==='number'?rec.stop_loss:null); const cAt=rec.created_at||rec.createdAt||rec.create_time||null; const uAt=rec.updated_at||rec.updatedAt||null; const tag = direction==='LONG'?'做多':(direction==='SHORT'?'做空':(direction||'--')); const baseEr=(typeof entry==='number' && typeof tp==='number')?(direction==='LONG'?((tp-entry)/entry):((entry-tp)/entry)):null; const erL=(typeof baseEr==='number')?((baseEr * (typeof lev==='number' && lev>0 ? lev : 1)) * 100):null; return `<div class=\"rec-item\" id=\"rec-${id}\"><div class=\"col main\"><div class=\"title\"><span class=\"badge ${direction==='LONG'?'long':(direction==='SHORT'?'short':'')}\">${tag}</span><span class=\"symbol\">${symbol}</span><span class=\"muted\">创建 ${formatRelative(cAt)}</span>${uAt?`<span class=\"muted\">更新 ${formatRelative(uAt)}</span>`:''}</div><div class=\"grid\"><div><span class=\"k\">入场</span> <span class=\"v\" data-field=\"entry_price-${id}\">${fmtPrice(entry)}</span></div><div><span class=\"k\">杠杆</span> <span class=\"v\" data-field=\"leverage-${id}\">${fmtLev(lev)}</span></div><div><span class=\"k\">预期收益</span> <span class=\"v\">${fmtPct(erL)}</span></div><div><span class=\"k\">止损</span> <span class=\"v\" data-field=\"stop_loss_price-${id}\">${fmtPrice(sl)}</span></div><div><span class=\"k\">止盈</span> <span class=\"v\" data-field=\"take_profit_price-${id}\">${fmtPrice(tp)}</span></div><div><span class=\"k\">置信度</span> <span class=\"v\">${fmtPct(conf)}</span></div></div></div>`; }).join('');
          container.innerHTML = `${topBar}<div class="rec-list" id="activeSignalList">${itemsHtml}</div>`;
          const btn=document.getElementById('btnManualRefresh'); if(btn) btn.onclick=()=>{ window.loadTradeRecommendation(); window.loadRecommendationHistory?.(); window.updateRecommendationStats?.(); };
          clearItemTimers(); ensureAutoRefreshTicker(); scheduleAutoRefresh();
          // 方案A：不再展示到期倒计时，仅做字段变化高亮
          sorted.slice(0,1).forEach(rec=>{ const id=rec.id||rec._id||rec.uuid||''; diffHighlight(id,rec); });
          document.querySelectorAll('[data-close-id]').forEach(el=>{ el.addEventListener('click', async()=>{ const id=el.getAttribute('data-close-id'); if(!id) return; if(el instanceof HTMLButtonElement){ el.disabled=true; el.textContent='关闭中...'; } try{ const resp=await fetch(`/api/recommendations/${id}/close`,{ method:'PUT', headers:{'Content-Type':'application/json'}, body: JSON.stringify({reason:'USER_CLOSED'}) }); if(!resp.ok) throw new Error(`关闭失败: ${resp.status}`); await window.loadTradeRecommendation(); window.updateRecommendationStats?.(); window.loadRecommendationHistory?.(); }catch(e){ alert('关闭失败：'+(e?.message||e)); if(el instanceof HTMLButtonElement){ el.disabled=false; el.textContent='关闭'; } } }); });
          // 同步旧版字段
          const latest = sorted[0];
          const actionRaw=latest?.direction||latest?.action||''; const action=String(actionRaw).toUpperCase();
          const entryVal=(typeof latest?.entry_price==='number')?latest.entry_price:(typeof latest?.current_price==='number'?latest.current_price:null);
          const levVal=(typeof latest?.leverage==='number')?latest.leverage:null;
          const tpVal=(typeof latest?.take_profit_price==='number')?latest.take_profit_price:(typeof latest?.take_profit==='number'?latest.take_profit:null);
          const slVal=(typeof latest?.stop_loss_price==='number')?latest.stop_loss_price:(typeof latest?.stop_loss==='number'?latest.stop_loss:null);
          const confRaw=(typeof latest?.confidence_score==='number')?latest.confidence_score:(typeof latest?.confidence==='number'?latest.confidence:null);
          const conf=(typeof confRaw==='number')?(((confRaw<=1?confRaw*100:confRaw)).toFixed(1)+'%'):'--';
          const a=document.getElementById('recommendedAction'); const e=document.getElementById('entryPrice'); const l=document.getElementById('recommendedLeverage'); const p=document.getElementById('positionSizeRecommend');
          if(a) a.textContent=action; if(e) e.textContent=(typeof entryVal==='number')?'$'+entryVal.toFixed(2):String(entryVal??'--'); if(l) l.textContent=(typeof levVal==='number')?(levVal+'x'):'--'; if(p) p.textContent=conf;
          window.__lastRecommendation={action, entry:entryVal, leverage:levVal, tp:tpVal, sl:slVal, conf};
          try{ setTradeButtonsState(action); }catch(_){ }
        } catch(err) {
          console.error('加载开单推荐失败:', err);
          const container = document.getElementById('tradingRecommendation');
          if (container) container.innerHTML = `${renderTopBar?.(0)||''}<div class=\"error\">推荐加载失败</div>`;
          ensureAutoRefreshTicker(); scheduleAutoRefresh();
        }
      };
      // 首次装载
      window.addEventListener('load', function(){ try{ window.loadTradeRecommendation(); }catch(e){} });

    })();

    // 打开推荐条件页面 - 全局函数
    function openConditionsPage() {
        window.open('/recommendation-conditions.html', '_blank', 'width=1200,height=800,scrollbars=yes,resizable=yes');
    }
    </script>
</body>
</html>
